---
layout: post
title: "arm-存储体系＜二＞"
subtitle: arm CP15中的寄存器
author: "404"
header-style: text
tags:
  - Linux
  - arm
  - Memory
---

>本篇文章来源于《ARM体系结构与编程》，写得挺好

CP15可以有16个32位的寄存器。下图介绍了这些寄存器的一般作用以及在特定的内存管理体系中的作用，这里介绍各寄存器在存储管理单元(MMU)与保护单元(PU)中的作用。本小节主要介绍寄存器C0和寄存器Cl, 其他的寄存器将在介绍各不同的内存管理体系时介绍。

![avatar](/img/in-post/Linux/201931102001.png)

#### CP15中的寄存器C0

寄存器C0中存放的是ARM相关的一些标识符。这个寄存器是只读的，当在MRC指令中指定不同的第2个操作码epc0de2时，读取到的是不同的标识符。 操作码epc0de2对应的标识符下图所示。
![avatar](/img/in-post/Linux/201931102002.png)
在这些epc0de2可能的取值中，主标识符是必须定义的，其他的标识符规范推荐定义。 如果在使用指令MRC读取寄存器C0时，操作码epc0de2指定的值是未定义的，指令将返回主标识符。因而其他标识符定义的值应该与主标识符不同，这样在读取其他标识符时应同时读取主标识符。如果两个标识符的值相同说明未定义该标识符；如果两个标识符值不相同，说明定义了该标识符，并且得到该标识符的值。

**标识符寄存器**

读取CP15的主标识寄存器的指令示例如下，该指令将主标识符寄存器的内容读取到ARM寄存器R0中：
```
MRC P15,0,R0,C0,C0,0
```

主标识符的编码格式对于不同的ARM处理器版本有所不同，其位[15: 12]标识了不同的处理器版木。具体对应关系下图所示。下面分别介绍对应不同处理器的主标识符的编码格式。
![avatar](/img/in-post/Linux/201931102003.png)

1. ARM7之后的处理器
对于ARM7之后的处理器，其主标识符的编码格式如下：
![avatar](/img/in-post/Linux/201931102004.png)
其中，各部分编码含义如下：
![avatar](/img/in-post/Linux/201931102005.png)

2. ARM7处理器
对于ARM7处理器，其主标识符的编码格式如下。其中编码中位[15: 12]的值为0x7。
![avatar](/img/in-post/Linux/201931102006.png)
其中，各部分编码含义如下：
![avatar](/img/in-post/Linux/201931102007.png)
![avatar](/img/in-post/Linux/201931102008.png)

3. ARM7之前的处理器
对于ARM7之前的处理器，其主标识符的编码格式如下。其中，编码中位[15:12]的俏为0x0。
![avatar](/img/in-post/Linux/201931102009.png)
其中，各部分编码含义如下：
![avatar](/img/in-post/Linux/201931102010.png)

**Cache类型标识符寄存器**

读取CP15的Cache类型标识符寄存器的指令示例如下，指令将Cache类型标识符寄存储器的内容读取到ARM寄存器R0中：
```
MRC P15,0,R0,C0,C0,1
```
Cache类型标识符定义了关于Cache的信息，具体包括以下部分：
- 系统中的数据Cache和指令Cache是分开的还是统一的
- Cache的容量、块大小以及相联特性
- Cache类型是写通的(Write-thR0ugh)还是写回的(Write-back)
- 对于写回(Write-back)类型的Cache如何有效清除Cache内容
- Cache是否支待内容锁定

关于Cache的基本概念和原理，在后面将有具体介绍，这里主要介绍Cache类型标识符寄存器各控制字段的含义，其编码格式如下所示：
![avatar](/img/in-post/Linux/201931102011.png)
其中，各部分控制字段的含义如下：
![avatar](/img/in-post/Linux/201931102012.png)

下面分别详细介绍Cache类型标识符寄存器各控制字段的含义：
1. 控制字段位[28:25]的含义
Cache类型标识符寄存器控制字段位[28:25]主要用于定义对于写回(Write-back)类型的Cache的一些属性，包括Cache内容的清除方法，内容锁定方法。这个字段含义的编码如下：
![avatar](/img/in-post/Linux/201931102013.png)
2. 控制字段位[23:12]及控制字段位[11:0]的含义
控制字段位[23:12]用于定义数据Cache的属性，控制字段位[11:0]用于定义指令Cache 的属性。控制字段位[23:12]及控制字段位[11:0]的结构相同。其中主要定义了Cache的容量、块大小以相关特性。具体编码及含义如下：
![avatar](/img/in-post/Linux/201931102014.png)
其中：
- 位[11:9]保留，用于将来扩展
- 位[8:6]定义Cache的容扯，其编码格式及含义如表5.9所示
- 位[1:0]定义Cache的块大小，其编码格式及含义如表5.10所示
- 位[5:3]定义Cache的相关特性，其编码格式及含义如表5.11
![avatar](/img/in-post/Linux/201931102015.png)

#### CP15中的寄存器C1

CP15中的寄存器C1是一个控制寄存器，它包括以下控制功能：
- 禁止/使能MMU以及其他的存储系统相关的功能
- 配置存储系统以及ARM处理器中的相关部分的工作方式

通过MRC指令可以将寄存器Cl中的值读取到ARM寄存器R0中， 这时CRm及0pc0de2的值应为0。例如，下面的指令可以将寄存器C1的值读取到ARM寄存器R0中
```
MRC P15,0,R0,C1,0,0
```
通过MCR指令，可以将ARM寄存器R0中的值写入到寄存器C1中，这时CRm及 0pc0de2的值应为0。例如，下面的指令可以将寄存器C1的值读取到ARM寄存器R0中：
```
MRC P15,0,R0,C1,0,0
```
在寄存器C1中包含一些现在没有使用的位，这些位将来可能在扩展其他功能时使用。因此，为了使编写的代码在将来不造成麻烦，在修改寄存器C1中的位时，应该使用\"读取－修改特定位－写入\"的操作序列。 例如， 下面的代码序列使能MMU
```
MRC P15,0,R0,C1,0,
0RR R0,#01
MCR P15,0,R0,C1,0,0
```
寄存器C1的编码格式如下所示：
![avatar](/img/in-post/Linux/201931102016.png)
寄存器C1中，各控制字段的含义如下：
![avatar](/img/in-post/Linux/201931102017.png)
![avatar](/img/in-post/Linux/201931102018.png)
![avatar](/img/in-post/Linux/201931102019.png)
