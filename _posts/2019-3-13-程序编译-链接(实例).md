---
layout: post
title: "程序编译-重定位(实例)"
subtitle: 实例来讲解重定位
author: "404"
header-style: text
tags:
  - Linux
  - arm
  - 程序编译
  - 重定位
---

>本篇文章是原创，转载请注明

这篇文章我们从实例来说明程序如何来重定位，我们把自己当成计算机，一步一步来走其中过程。当然，我们首先需要一段代码，代码我们就选取《深入理解计算机系统》第七章中的代码。如下：
```c
/* main.c */

void swap();
int buf[5] = {31, 2, 14, 7, 88};
int test;

int main()
{
	int x = 16;
	int y;
	static static_x;
	static static_y = 1024;
	static int s = 15;
	swap();
	return 0;
}

int sss()
{
	static int s = 243;
}

```
```c

/* swap.c */

extern int buf[];
void swap();

int *bufp0 = &buf[0];
int *bufp1 ;
int test = 1;
int test2 = 324;

void swap()
{
	int temp;

	bufp1 = &buf[1];
	temp = *bufp0;
	*bufp0 = *bufp1;
	*bufp0 = temp;
	test = 10;

}

```
我在其中加了一些其他玩意以供分析使用。再自己写个`Makefile`或者不嫌麻烦手动一条一条去编译，我们生成了`main.o`和`swap.o`文件，接下来以这两个文件来分析。

我们经过前面的文章，知道elf的一些基本格式，如下：

![avatar](/img/in-post/Linux/201931201002.png)

段表的详细结构如下，我们后面会结合实例来说。

![avatar](/img/in-post/Linux/201931301001.png)

符号表的具体格式如下：

![avatar](/img/in-post/Linux/201931301002.png)

首先我们不考虑生成两个文件的链接，我们单独那`main.o`来看，我们可先看看段表：

![avatar](/img/in-post/Linux/201931301003.png)

与之同时，我们还可以得到符号表：
![avatar](/img/in-post/Linux/201931301004.png)

在符号表中，我们可以段表画的图来理解。我们看到符号表中：
- 函数中的静态局部变量：只要是函数中的静态局部变量都是以`原名称.<数字>`形式生成，即使我们在不同函数中定义了相同的变量，我们也能区分；
- 函数中的局部变量：函数中的局部变量是不在符号表中的，它是在程序运行过程中堆栈中生成的；
- 全局变量
- 静态全局变量，大家可以自己看看初始化和未初始化的全局变量放在`Section`位置有什么不同
- 函数

同时可以看到，这个文件对应着12个节（section），并且为其编号了。在地址那栏，由于我们还没有进行链接，故现在都为0。其中链接和信息，对应第一张图中的`link`和`inf`。举个例子，重定位`.rela.text`时，`link`为10，`inf`为1，我们找图中对应的标号，可以翻译为，`.symtab`中的内容会重定位，重定位到哪里呢？其实就是去`.text`里面去修改相应的值。我们现在来看下`.rela.text`里面的值：
![avatar](/img/in-post/Linux/201931301005.png)

我们看到其中有偏移量，信息。这两者的用途是这样：
- 信息分为两部分，前2个字节是告诉我们符号表中哪个对应的符号去修改，这里是`0x0010`，对应符号表中的16，对应的也就是`swap`，这里注意进制转换，一个是十六进制，一个是十进制。后面6个字节是告诉我们重定位类型，不同的重定位类型算法不同，这里的重定位类型是`R_X86_64_PLT32`。
- 偏移量是指链接时需要修改值的地方，也就是需要在`.text`里哪里去修改。这里是`0X15`

下面我们看看`.text`段：
![avatar](/img/in-post/Linux/201931301006.png)

我们可以看到`0x14`对应的是`e8 00 00 00 00`，`e8`是跳转指令`call`的编码，然后上面告诉我们的是去`0x15`去修改，此时这里的值0，也就是修改这里让程序知道怎么跳转。

我们现在进行两段程序ld，就是将这两段程序合并在一起，此时就会把各个相同的`section`合并在一起，同时如果没有指定地址的话，ld会默认给分配一个地址作为初始化地址，即运行时虚拟地址。我们看下链接后的结果：
![avatar](/img/in-post/Linux/201931301007.png)

这里`call swap`中有值了，即`e8`后面有值了，这就是ld计算出来的，如何得出这个数呢？跟做数学题一样，ld将各个段合并到一起后，我们已知的条件如下：
- ADDR(s)=ADDR(.text) = 0x4000e8
- ADDR(r.offset)=0X15
- ADDR(r.symbol)=ADDR(.swap) = 400010f

现在我们需要根据这些条件来计算程序需要跳转多少 。可能你会说，既然都知道`.swap`在哪里了，直接跳转不就行了？其实就是这样，我们一目了然看到了地址，但是程序是需要调用`call`指令，我们需要转换成程序对应的格式。

那么需要跳转多少也就是一个简单的减法了，我们叫它`jump_offset`，那么`jump_offset = ADDR(.swap) - ( ADDR(.text) + ADDR(r.offset) ) = 0x12。你这时可能就会说了，这里和图中对应的`0xe`不相等啊!这里还需要稍等下，我们以前介绍过指令的流水线体系，不同流水线体系执行过程中PC会提前向指向后面指令，这个具体去看我之前的文章。此时我们的三指令流水线体系就提前了一个指令，相当于我们在执行`call swap`的时候，PC已经指向了下一个指令，而跳转是根据PC + offset来计算了，所以我们需要将提前的一个指令减去，这是4字节，此时就会得到 0x12 -0x4 = 0xe。现在就正确了。还有忘了说一句，我们这个程序是小端编码，所以0xe出现在指令最前端。
