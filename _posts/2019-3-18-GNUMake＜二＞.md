---
layout: post
title: "GNU Make"
subtitle: GNU Make分析
author: "404"
header-style: text
tags:
  - Linux
  - GNU
  - Make
---

>本篇文章来源于《GNU Make 手册》

# 第一章：概述

## 1.1 概述

&emsp;&emsp;Linux 环境下的程序员如果不会使用 GNU make 来构建和管理自己的工程,应该
不能算是一个合格的专业程序员,至少不能称得上是 Unix 程序员。在 Linux(unix)环
境下使用 GNU 的 make 工具能够比较容易的构建一个属于你自己的工程,整个工程的
编译只需要一个命令就可以完成编译、连接以至于最后的执行。不过这需要我们投入一
些时间去完成一个或者多个称之为 Makefile 文件的编写。此文件正是 make 正常工作
的基础。  

&emsp;&emsp;所要完成的 Makefile 文件描述了整个工程的编译、连接等规则。其中包括:工程
中的哪些源文件需要编译以及如何编译、需要创建那些库文件以及如何创建这些库文
件、如何最后产生我们想要得可执行文件。尽管看起来可能是很复杂的事情,但是为工
程编写 Makefile 的好处是能够使用一行命令来完成“自动化编译”,一旦提供一个(通
常对于一个工程来说会是多个)正确的 Makefile。编译整个工程你所要做的唯一的一件
事就是在 shell 提示符下输入 make 命令。整个工程完全自动编译,极大提高了效率。

&emsp;&emsp;make 是一个命令工具,它解释 Makefile 中的指令(应该说是规则)。在 Makefile
文件中描述了整个工程所有文件的编译顺序、编译规则。Makefile 有自己的书写格式、
关键字、函数。像 C 语言有自己的格式、关键字和函数一样。而且在 Makefile 中可以
使用系统 shell 所提供的任何命令来完成想要的工作。Makefile(在其它的系统上可能
是另外的文件名)在绝大多数的 IDE 开发环境中都在使用,已经成为一种工程的编译
方法。

&emsp;&emsp;目前,系统完整的介绍 make 工具和如何编写 Makefile 的中文文档比较少。我整
理这个文档就是希望能使众多的 Linux 环境下的程序员能够比较容易的掌握和学会使
用 GNU make。本文所要介绍的是 GNU 的 make,采用 Red Hat FC3(包括最新发布
的 GNU Linux 系统)所集成的 GUN make 工具。

&emsp;&emsp;本文中所有示例均采用 C 语言的源程序,因为它是目前最普遍使用的一种语言。
当然 make 工具不仅仅是用来管理 C 语言工程的,那些编译器只要能够在 shell 下运行
的语言所构建的工程都可以使用 make 工具来管理。Make 工作不仅仅可以用来编译源
代码,它也可以完成一些其它的功能。例如,有这样的需求:当我们修改了某个或者某些文件后,需要能够根据修改的文件来自动对相关文件进行重建或者更新。那么应该考
虑使用 GNU make 工具。 GNU make 工具为我们实现这个目的提供了非常有利的支持。
工程中根据源文件的修改情况来进行代码的编译正是使用了 make 的这个特征。make
执行时,根据 Makefile 的规则检查文件的修改情况,决定是否执行定义的动作(那些
修改过的文件将会被重新编译)。这是 GNU make 的执行依据。

## 1.2 准备知识

&emsp;&emsp;在开始我们关于 make 的讨论之前,首先需要明确一些基本概念:

&emsp;&emsp;编译:把高级语言书写的代码转换为机器可识别的机器指令。编译高级语言后生成
的指令虽然可被机器识别,但是还不能被执行。编译时,编译器检查高级语言的语法、
函数与变量的声明是否正确。只有所有的语法正确、相关变量定义正确编译器就可以编
译出中间目标文件。通常,一个高级语言的源文件都可对应一个目标文件。目标文件在
Linux 中默认后缀为“.o”(如“foo.c”的目标文件为“foo.o”)。

&emsp;&emsp;**为了和规则的目标文件相区别。本文将编译高级语言后生成的目标文件成为.o文件。**

&emsp;&emsp;链接:将多.o 文件,或者.o 文件和库文件链接成为可被操作系统执行的可执行程序(Linux 环境下,可执行文件的格式为“ELF”格式)。链接器不检查函数所在的源文
件,只检查所有.o 文件中的定义的符号。将.o 文件中使用的函数和其它.o 或者库文件
中的相关符号进行合并,对所有文件中的符号进行重新安排(重定位),并链接系统相
关文件(程序启动文件等)最终生成可执行程序。链接过程使用 GNU 的“ld”工具。
静态库:又称为文档文件(Archive File)。它是多个.o 文件的集合。Linux 中静态
库文件的后缀为“.a”。静态库中的各个成员(.o 文件)没有特殊的存在格式,仅仅是
一个.o 文件的集合。使用“ar”工具维护和管理静态库。

 &emsp;&emsp;共享库:也是多个.o 文件的集合,但是这些.o 文件时有编译器按照一种特殊的方
式生成(Linux 中,共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条
件)。模块中各个成员的地址(变量引用和函数调用)都是相对地址。使用此共享库的
程序在运行时,共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程
序可共享库文件的代码段(多个程序可以共享的使用库中的某一个模块,共享代码,不
共享数据)。另外共享库的成员对象可被执行(由 libdl.so 提供支持)。

&emsp;&emsp; 参考 info ld 了解更加详细的关于 ld 的说明和用法。

# 第二章 GNU make 介绍

&emsp;&emsp;make 在执行时,需要一个命名为 Makefile 的文件。这个文件告诉 make 以何种方
式编译源代码和链接程序。典型地,可执行文件可由一些.o 文件按照一定的顺序生成
或者更新。如果在你的工程中已经存在一个活着多个正确的 Makefile。当对工程中的若
干源文件修改以后,需要根据修改来更新可执行文件或者库文件,正如前面提到的你只
需要在 shell 下执行“make”。make 会自动根据修改情况完成源文件的对应.o 文件的
更新、库文件的更新、最终的可执行程序的更新。

&emsp;&emsp; make 通过比较对应文件(规则的目标和依赖,)的最后修改时间,来决定哪些文
件需要更新、那些文件不需要更新。对需要更新的文件 make 就执行数据库中所记录的
相应命令(在 make 读取 Makefile 以后会建立一个编译过程的描述数据库。此数据库
中记录了所有各个文件之间的相互关系,以及它们的关系描述)来重建它,对于不需要
重建的文件 make 什么也不做。

&emsp;&emsp;而且可以通过make的命令行选项来指定需要重新编译的文件。

## 2.1 Makefile简介

&emsp;&emsp;在执行 make 之前,需要一个命名为 Makefile 的特殊文件(本文的后续将使用
Makefile 作为这个特殊文件的文件名)来告诉 make 需要做什么(完成什么任务),该
怎么做。通常,make 工具主要被用来进行工程编译和程序链接。

&emsp;&emsp;本节将分析一个简单的 Makefile,它对一个包含 8 个 C 的源代码和三个头文件的
工程进行编译和链接。这个 Makefile 提供给了 make 必要的信息,make 程序根据
Makefile 中的规则描述执行相关的命令来完成指定的任务(如:编译、链接和清除编译
过程文件等)。复杂的 Makefile 我们将会在本文后续进行讨论。

&emsp;&emsp;当使用 make 工具进行编译时,工程中以下几种文件在执行 make 时将会被编译
(重新编译):
- 所有的源文件没有被编译过,则对各个 C 源文件进行编译并进行链接,生成最
后的可执行程序;
- 每一个在上次执行 make 之后修改过的 C 源代码文件在本次执行 make 时将会
被重新编译;
- 头文件在上一次执行 make 之后被修改。则所有包含此头文件的 C 源文件在本
次执行 make 时将会被重新编译。

&emsp;&emsp;后两种情况是 make 只将修改过的 C 源文件重新编译生成.o 文件,对于没有修改
的文件不进行任何工作。重新编译过程中,任何一个源文件的修改将产生新的对应的.o
文件,新的.o 文件将和以前的已经存在、此次没有重新编译的.o 文件重新连接生成最
后的可执行程序。

&emsp;&emsp;首先让我们先来看一些 Makefile 相关的基本知识。

## 2.2 Makefile规则介绍

&emsp;&emsp;一个简单的Makefile描述规则组成：
```make
TARGET... : PREREQUISITES...
	COMMAND
	...
	...
```
 &emsp;&emsp;**target**:规则的目标。通常是最后需要生成的文件名或者为了实现这个目的而必需
的中间过程文件名。可以是.o文件、也可以是最后的可执行程序的文件名等。另外,目
标也可以是一个make执行的动作的名称,如目标“clean”,我们称这样的目标是“伪
目标”。

&emsp;&emsp;**prerequisites**:规则的依赖。生成规则目标所需要的文件名列表。通常一个目标依
赖于一个或者多个文件。

 &emsp;&emsp;**command**:规则的命令行。是规则所要执行的动作(任意的 shell 命令或者是可在
shell 下执行的程序)。它限定了 make 执行这条规则时所需要的动作。
一个规则可以有多个命令行,每一条命令占一行。注意:每一个命令行必须以[Tab]
字符开始,[Tab]字符告诉 make 此行是一个命令行。make 按照命令完成相应的动作。
这也是书写 Makefile 中容易产生,而且比较隐蔽的错误。

 &emsp;&emsp;命令就是在任何一个目标的依赖文件发生变化后重建目标的动作描述。一个目标可
以没有依赖而只有动作(指定的命令)
。比如 Makefile 中的目标“clean”,此目标没有
依赖,只有命令。它所定义的命令用来删除 make 过程产生的中间文件(进行清理工作)。

 &emsp;&emsp;在 Makefile 中“规则”就是描述在什么情况下、如何重建规则的目标文件,通常
规则中包括了目标的依赖关系(目标的依赖文件)和重建目标的命令。make 执行重建
目标的命令,来创建或者重建规则的目标(此目标文件也可以是触发这个规则的上一个
规则中的依赖文件)。规则包含了文件之间的依赖关系和更新此规则目标所需要的命令。

 &emsp;&emsp;一个 Makefile 文件中通常还包含了除规则以外的很多东西(后续我们会一步一步
的展开)。一个最简单的 Makefile 可能只包含规则。规则在有些 Makefile 中可能看起来
非常复杂,但是无论规则的书写是多么的复杂,它都符合规则的基本格式。

 &emsp;&emsp;make 程序根据规则的依赖关系,决定是否执行规则所定义的命令的过程我们称之
为执行规则。

## 2.3 简单的示例

&emsp;&emsp;本小节开始我们在第一小节中提到的例子。此例子由3个头文件和8个C文件组成。
我们将书写一个简单的Makefile,来描述如何创建最终的可执行文件“edit”,此可执行
文件依赖于8个C源文件和3个头文件。Makefile文件的内容如下:
```make
#sample Makefile
edit : main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o
```
&emsp;&emsp;首先书写时,可以将一个较长行使用反斜线(\)来分解为多行,这样可以使我们
的Makefile书写清晰、容易阅读理解。但需要注意:反斜线之后不能有空格(这也是大
家最容易犯的错误,错误比较隐蔽)。我们推荐将一个长行分解为使用反斜线连接得多
个行的方式。在完成了这个Maekfile以后;需要创建可执行程序“edit”,所要做的就是
在包含此Makefile的目录(当然也在代码所在的目录)下输入命令“make”。删除已经
此目录下之前使用“make”生成的文件(包括那些中间过程的.o文件),也只需要输入
命令“make clean”就可以了。

&emsp;&emsp;在这个Makefile中,我们的目标(target)就是可执行文件“edit”和那些.o文件
(main.o,kbd.o....);依赖(prerequisites)就是冒号后面的那些 .c 文件和 .h文件。
所有的.o文件既是依赖(相对于可执行程序edit)又是目标(相对于.c和.h文件)。命令
包括 “cc –c maic.c”、“cc –c kbd.c”......

&emsp;&emsp;当规则的目标是一个文件,在它的任何一个依赖文件被修改以后,在执行“make”
时这个目标文件将会被重新编译或者重新连接。当然,此目标的任何一个依赖文件如果
有必要则首先会被重新编译。在这个例子中,“edit”的依赖为8个.o文件;而“main.o”的依赖文件为“main.c”和“defs.h”。当“main.c”或者“defs.h”被修改以后,再次
执行“make”,“main.o”就会被更新(其它的.o文件不会被更新),同时“main.o” 的
更新将会导致“edit”被更新。

&emsp;&emsp;在描述依赖关系行之下通常就是规则的命令行(存在一些些规则没有命令行),命
令行定义了规则的动作(如何根据依赖文件来更新目标文件)。命令行必需以[Tab]键开
始,以和Makefile其他行区别。就是说所有的命令行必需以[Tab] 字符开始,但并不是
所有的以[Tab]键出现行都是命令行。但make程序会把出现在第一条规则之后的所有以
[Tab]字符开始的行都作为命令行来处理。(记住:make程序本身并不关心命令是如何
工作的,对目标文件的更新需要你在规则描述中提供正确的命令。“make”程序所做的
就是当目标程序需要更新时执行规则所定义的命令)。

&emsp;&emsp;目标“clean”不是一个文件,它仅仅代表执行一个动作的标识。正常情况下,不
需要执行这个规则所定义的动作,因此目标“clean”没有出现在其它任何规则的依赖
列表中。因此在执行make时,它所指定的动作不会被执行。除非在执行make时明确地
指定它。而且目标“clean”没有任何依赖文件,它只有一个目的,就是通过这个目标
名来执行它所定义的命令。Makefile中把那些没有任何依赖只有执行动作的目标称为
“伪目标”(phony targets)。需要执行“clean”目标
所定义的命令,可在shell下输入:make clean。

## 2.4 make如何工作

&emsp;&emsp;默认的情况下,make执行的是Makefile中的第一个规则,此规则的第一个目标称
之为“最终目的”或者“终极目标”(就是一个Makefile最终需要更新或者创建的目标,
参考9.2 指定终极目标 一节)。

&emsp;&emsp;上例的 Makefile,目标“edit”在 Makefile 中是第一个目标,因此它就是 make 的
“终极目标”。当修改了任何 C 源文件或者头文件后,执行 make 将会重建终极目标
“edit”。

&emsp;&emsp;当在 shell 提示符下输入“make”命令以后。make 读取当前目录下的 Makefile 文
件,并将 Makefile 文件中的第一个目标作为其执行的“终极目标”,开始处理第一个规
则(终极目标所在的规则)。在我们的例子中,第一个规则就是目标“edit”所在的规
则。规则描述了“edit”的依赖关系,并定义了链接.o 文件生成目标“edit”的命令; make
在执行这个规则所定义的命令之前,首先处理目标“edit”的所有的依赖文件(例子中
的那些.o 文件)的更新规则(以这些.o 文件为目标的规则)。对这些.o 文件为目标的规
则处理有下列三种情况:
- 目标.o 文件不存在,使用其描述规则创建它;
- 目标.o 文件存在,目标.o 文件所依赖的.c 源文件、 .h 文件中的任何一个比目标.o
文件“更新”(在上一次 make 之后被修改)。则根据规则重新编译生成它;
- 目标.o 文件存在,目标.o 文件比它的任何一个依赖文件(的.c 源文件、.h 文件)“更新”(它的依赖文件在上一次 make 之后没有被修改),则什么也不做。

&emsp;&emsp;这些.o 文件所在的规则之所以会被执行,是因为这些.o 文件出现在“终极目标”
的依赖列表中。在 Makefile 中一个规则的目标如果不是“终极目标”所依赖的(或者
“终极目标”的依赖文件所依赖的)
,那么这个规则将不会被执行,除非明确指定执行
这个规则(可以通过 make 的命令行指定重建目标,那么这个目标所在的规则就会被执
行,例如 “make clean”)。在编译或者重新编译生成一个.o 文件时,make 同样会去
寻找它的依赖文件的重建规则(是这样一个规则:这个依赖文件在规则中作为目标出
现),在这里就是.c 和.h 文件的重建规则。在上例的 Makefile 中没有哪个规则的目标是.c
或者.h 文件,所以没有重建.c 和.h 文件的规则。不过 C 言语源程序文件可以使用工具
Bison 或者 Yacc 来生成(具体用法可参考相应的手册)。

&emsp;&emsp;完成了对.o文件的创建(第一次编译)或者更新之后,make 程序将处理终极目标
“edit”所在的规则,分为以下三种情况:
- 目标文件“edit”不存在,则执行规则以创建目标“edit”。
- 目标文件“edit”存在,其依赖文件中有一个或者多个文件比它“更新”,则根
据规则重新链接生成“edit”。
- 目标文件“edit”存在,它比它的任何一个依赖文件都“更新”,则什么也不做。

&emsp;&emsp;上例中,如果更改了源文件“insert.c”后执行 make,“insert.o”将被更新,之后
终极目标“edit”将会被重生成;如果我们修改了头文件“command.h”之后运行“make”,
那么“kbd.o”、“command.o”和“files.o”将会被重新编译,之后同样终极目标“edit”也将被重新生成。

&emsp;&emsp;以上我们通过一个简单的例子,介绍了 Makefile 中目标和依赖的关系。我们简单
总结一下:对于一个 Makefile 文件,“make”首先解析终极目标所在的规则(上节例
子中的第一个规则),根据其依赖文件(例子中第一个规则的 8 个.o 文件)依次(按照
依赖文件列表从左到右的顺序)寻找创建这些依赖文件的规则。首先为第一个依赖文件
(main.o)寻找创建规则,如果第一个依赖文件依赖于其它文件(main.c、defs.h),
则同样为这个依赖文件寻找创建规则(创建 main.c 和 defs.h 的规则,通常源文件和头
文件已经存在,也不存在重建它们的规则)......,直到为所有的依赖文件找到合适的创
建规则。之后 make 从最后一个规则(上例目标为 main.o 的规则)回退开始执行,最
终完成终极目标的第一个依赖文件的创建和更新。之后对第二个、第三个、第四个......
终 极 目 标 的 依 赖 文 件 执 行 同 样 的 过 程 ( 上 例 的 的 顺 序 是 “ main.o ”、“ kbd.o ”、
“command.o”......)。

&emsp;&emsp;创建或者更新每一个规则依赖文件的过程都是这样的一个过程(类似于 c 语言中的
递归过程)。对于任意一个规则执行的过程都是按照依赖文件列表顺序,对于规则中的
每一个依赖文件,使用同样方式(按照同样的过程)去重建它,在完成对所有依赖文件
的重建之后,最后一步才是重建此规则的目标。

&emsp;&emsp;更新(或者创建)终极目标的过程中,如果任何一个规则执行出现错误 make 就立
即报错并退出。整个过程 make 只是负责执行规则,而对具体规则所描述的依赖关系的
正确性、规则所定义的命令的正确性不做任何判断。就是说,一个规则的依赖关系是否
正确、描述重建目标的规则命令行是否正确,make 不做任何错误检查。

&emsp;&emsp;因此,需要正确的编译一个工程。需要在提供给 make 程序的 Makefile 中来保证
其依赖关系的正确性、和执行命令的正确性。

## 2.5 制定变量

&emsp;&emsp;同样是上边的例子，我们来看一下终极目标“edit”所在的规则：
```make
edit : main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
```
&emsp;&emsp;在这个规则中.o 文件列表出现了两次;第一次:作为目标“edit”的依赖文件列表出现,第二次:规则命令行中作为“cc”的参数列表。这样做所带来的问题是:如果我
们需要为目标“edit”增加一个的依赖文件,我们就需要在两个地方添加(依赖文件列
表和规则的命令中)。添加时可能在“edit”的依赖列表中加入了、但却忘记了给命令
行中添加,或者相反。这就给后期的维护和修改带来了很多不方便,添加或修改时出现
遗漏。

&emsp;&emsp;为了避免这个问题,在实际工作中大家都比较认同的方法是,使用一个变量
“objects”、“OBJECTS”、“objs”、“OBJS”、“obj”或者“OBJ”来作为所有的.o 文
件的列表的替代。在使用到这些文件列表的地方,使用此变量来代替。在上例的 Makefile
中我们可以添加这样一行:
```make
objects = main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
```
&emsp;&emsp;“objects”作为一个变量,它代表所有的.o文件的列表。在定义了此变量后,我们
就可以在需要使用这些.o文件列表的地方使用“$(objects)”来表示它,而不需要罗列
所有的.o文件列表(变量可参考 第六章 使用变量)。因此上例的规则就可以这样写:
```make
objects = main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
edit : $(objects)
	cc -o edit $(objects)
	.......
	.......
clean :
	rm edit $(objects)
```

&emsp;&emsp;当我们需要为终极目标“edit”增加或者去掉一个.o 依赖文件时,只需要改变
“objects”的定义(加入或者去掉若干个.o 文件)。这样做不但减少书写的工作量,而
且可以减少修改而产生错误的可能。

## 2.6 自动推导规则

&emsp;&emsp;在使用make编译.c源文件时,编译.c源文件规则的命令可以不用明确给出。这是因
为make本身存在一个默认的规则,能够自动完成对.c文件的编译并生成对应的.o文件。
它执行命令“cc -c”来编译.c源文件。在Makefile中我们只需要给出需要重建的目标文
件名(一个.o文件),make会自动为这个.o文件寻找合适的依赖文件(对应的.c文件。
对应是指:文件名除后缀外,其余都相同的两个文件),而且使用正确的命令来重建这
个目标文件。对于上边的例子,此默认规则就使用命令“cc -c main.c -o main.o”来创
建文件“main.o”。对一个目标文件是“N.o”,倚赖文件是“N.c”的规则,完全可以省
略其规则的命令行,而由make自身决定使用默认命令。此默认规则称为make的隐含规
则(关于隐含规则可参考 第十章 使用隐含规则)

&emsp;&emsp;这样,在书写 Makefile 时,我们就可以省略掉描述.c 文件和.o 依赖关系的规则,
而只需要给出那些特定的规则描述(.o 目标所需要的.h 文件)。因此上边的例子就可以
以更加简单的方式书写,我们同样使用变量“objects”。Makefile 内容如下:
```make
# sample Makefile
objects = main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
	rm edit $(objects)
```
&emsp;&emsp;这种格式的Makefile更接近于我们实际应用。(关于目标“clean”的详细说明我们
在后边。参考4.6 Makefile伪目标 一节 和 5.4 命令的错误 一节)

&emsp;&emsp;make 的隐含规则在实际工程的 make 中会经常使用,它使得编译过程变得方便。
几乎在所有的 Makefile 中都用到了 make 的隐含规则, make 的隐含规则是非常重要的
一个概念。后续我们会在第十章会有专门的讨论。

## 2.7 另类风格的makefile

&emsp;&emsp;上一节中我们提到过, Makefile 中,所有的.o 目标文件都可以使用隐含规则由 make
自动重建,我们可以根据这一点书写更加简洁的 Makefile。而且在这个 Makefile 中,
我们是根据依赖而不是目标对规则进行分组。形成另外一种风格的 Makefile。实现如下:
```make
#sample Makefile
objects = main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
edit : $(objects)
	cc -o edit $(objects)
$(objects) : defs.h
	kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
```

&emsp;&emsp;本例中,我们以三个头文件为出发点,对依赖于每一个头文件的目标进行合并。书
写出一个多目标规则,规则中多个目标同时依赖于对应的头文件,而且同一个文件可能
同时存在多个规则中。例子中头文件“defs.h”作为所有.o 文件的依赖文件。其它两个
头文件作为规则所有目标文件(多个.o 文件)的依赖文件。

&emsp;&emsp;这种风格的 Makefile 并不值得我们借鉴。问题在于:同时把多个目标文件的依赖
放在同一个规则中进行描述(一个规则中含有多个目标文件),这样导致规则定义不明
了,比较混乱。建议大家不要在 Makefile 中采用这种方式了书写。否则后期维护将会
是一件非常痛苦的事情。

&emsp;&emsp;书写规则建议的方式是:单目标,多依赖。就是说尽量要做到一个规则中只存在一
个目标文件,可有多个依赖文件。尽量避免使用多目标,单依赖的方式。这样书写的好
处是后期维护会非常方便,而且这样做会使 Makefile 会更清晰、明了。

## 2.8 清除工作目录过程文件

&emsp;&emsp;规则除了完成源代码编译之外,也可以完成其它任务。例如:前边提到的为了实现
清除当前目录中编译过程中产生的临时文件(edit 和哪些.o 文件)的规则:
```make
clean :
	rm edit $(objects)
```
&emsp;&emsp;在实际应用时,我们把这个规则写成如下稍微复杂一些的样子。以防止出现始料未
及的情况。

```make
.PHONY : clean
clean :
	-rm edit $(objects)
```

&emsp;&emsp;这两个实现有两点不同: 
- 通过“.PHONY”特殊目标将“clean”目标声明为伪
目标。避免当磁盘上存在一个名为“clean”文件时,目标“clean”所在规则的命令无
法执行(参考 4.6 Makefile伪目标一节)。 
- 在命令行之前使用“-”,意思是忽略命令“rm”的执行错误(参考 5.4 命令的错误 一节)。

&emsp;&emsp;这样的一个目标在 Makefile 中,不能将其作为终极目标(Makefile 的第一个目标)。
因为我们的初衷并不是当你在命令行上输入 make 以后执行删除动作。而是要创建或者
更新程序。在我们上边的例子中。就是在输入 make 以后要需要对目标“edit”进行创
建或者重建。
&emsp;&emsp;上例中因为目标“clean”没有出现在终极目标“edit”依赖关系中(终极目标的直
接依赖或者间接依赖),所以我们执行“make”时,目标“clean”所在的规则将不会
被处理。当需要执行此规则,要在make的命令行选项中明确指定这个目标(执行“make
clean”)。关于make的执行可参考 9.2 指定终极目标 一节

# 第三章：Makefile总述

## 3.1 Makefile的内容

&emsp;&emsp;在一个完整的Makefile中，包含了5个东西：显示规则、隐含规则、变量定义、指示符和注释。关于“规则”、“变量”和“Makefile指示符”将在后续的章节进行详细的讨论。
本章讨论的是一些基本概念。
- 显示规则：它描述了在何种情况下如何更新一个或者多个被称为目标的文件
(Makefile 的目标文件)。书写 Makefile 时需要明确地给出目标文件、目标的
依赖文件列表以及更新目标文件所需要的命令(有些规则没有命令,这样的
规则只是纯粹的描述了文件之间的依赖关系)。
- 隐含规则:它是make根据一类目标文件(典型的是根据文件名的后缀)而自
动推导出来的规则。make根据目标文件的名,自动产生目标的依赖文件并使
用默认的命令来对目标进行更新(建立一个规则)。关于隐含规则可参考 第
十章 make的隐含规则
- 变量定义:使用一个字符或字符串代表一段文本串,当定义了一个变量以后,
Makefile后续在需要使用此文本串的地方,通过引用这个变量来实现对文本串
的使用。第一章的例子中,我们就定义了一个变量“objects”来表示一个.o
文件列表。关于变量的详细讨论可参考 第六章 Makefile中的变量
- Makefile 指示符:指示符指明在 make 程序读取 makefile 文件过程中所要执
行的一个动作。其中包括:
	- 读取一个文件,读取给定文件名的文件,将其内容作为makefile文件的一
部分。参考 3.3 包含其它makefile文件一节
	- 决定(通常是根据一个变量的得值)处理或者忽略Makefile中的某一特定
部分。参考 第七章Makefile的条件执行
	- 定义一个多行变量。参考 6.8 多行定义 一节
- 注释:Makefile 中“#”字符后的内容被作为是注释内容(和 shell 脚本一样)
处理。如果此行的第一个非空字符为“#”,那么此行为注释行。注释行的结
尾如果存在反斜线(\),那么下一行也被作为注释行。一般在书写 Makefile
时推荐将注释作为一个独立的行,而不要和 Makefile 的有效行放在一行中书
写。当在 Makefile 中需要使用字符“#”时,可以使用反斜线加“#”(\#)来
实现(对特殊字符“#”的转义),其表示将“#”作为一字符而不是注释的开
始标志。

**&emsp;&emsp;需要注意的地方：**

&emsp;&emsp;Makefile 中第一个规则之后的所有以[Tab]字符开始的的行, make 程序都会将其交
给系统 shell 程序去解释执行。因此,以[Tab]字符开始的注释行也会被交给 shell 来处
理,此命令行是否需要被执行(shell 执行或者忽略)是由系统 shell 程序来判决的。
另外,在使用指示符“define”定义一个多行的变量或者命令包时,其定义体
(“define”和“endef”之间的内容)会被完整的展开到 Makefile 中引用此变量的地方
(包含定义体中的注释行);make 在引用此变量的地方对所有的定义体进行处理,决
定是注释还是有效内容。Makefile 中变量的引用和 C 语言中的宏类似(但是其实质并
不相同,后续将会详细讨论)。对一个变量引用的地方 make 所做的就是将这个变量根
据定义进行基于文本的展开,展开变量的过程不涉及到任何变量的具体含义和功能分
析。akefile 中第一个规则之后的所有以[Tab]字符开始的的行, make 程序都会将其交
给系统 shell 程序去解释执行。因此,以[Tab]字符开始的注释行也会被交给 shell 来处
理,此命令行是否需要被执行(shell 执行或者忽略)是由系统 shell 程序来判决的。

&emsp;&emsp;另外,在使用指示符“define”定义一个多行的变量或者命令包时,其定义体
(“define”和“endef”之间的内容)会被完整的展开到 Makefile 中引用此变量的地方
(包含定义体中的注释行);make 在引用此变量的地方对所有的定义体进行处理,决
定是注释还是有效内容。Makefile 中变量的引用和 C 语言中的宏类似(但是其实质并
不相同,后续将会详细讨论)。对一个变量引用的地方 make 所做的就是将这个变量根
据定义进行基于文本的展开,展开变量的过程不涉及到任何变量的具体含义和功能分
析。

## 3.2 makefile文件的命名

&emsp;&emsp;默认的情况下，make会在工作目录（执行make的目录）下按照文件名顺序寻找make文件读取并执行，查找的文件名顺序为：“GNUmakefile”、“makefile”、“Makefile”。

&emsp;&emsp;通常应该使用“makefile”或者“Makefile”作为一个 makefile 的文件名(我们推
荐使用“Makefile”,首字母大写而比较显著,一般在一个目录中和当前目录的一些重
要 文 件 ( README,Chagelist 等 ) 靠 近 , 在 寻 找 时 会 比 较 容 易 的 发 现 它 )。 而
“GNUmakefile”是我们不推荐使用的文件名,因为以此命名的文件只有“GNU make”
才可以识别,而其他版本的 make 程序只会在工作目录下“makefile”和“Makefile”
这两个文件。

&emsp;&emsp;如果make程序在工作目录下无法找到以上三个文件中的任何一个,它将不读取任
何其他文件作为解析对象。但是根据make隐含规则的特性,我们可以通过命令行指定
一个目标,如果当前目录下存在符合此目标的依赖文件,那么这个命令行所指定的目标
将会被创建或者更新,参见注释。(详细可参考 第十章 make的隐含规则)

&emsp;&emsp;当 makefile 文件的命名不是这三个任何一个时,需要通过 make 的“-f”或者“--file”
选项来指定 make 读取的 makefile 文件。给 make 指定 makefile 文件的格式为:“-f
NAME”或者“—file=NAME”,它指定文件“NAME”作为执行 make 时读取的 makefile
文件。也可以通过多个“-f”或者“--file”选项来指定多个需要读取的 makefile 文件,
多个 makefile 文件将会被按照指定的顺序进行链接并被 make 解析执行。当通过“-f”
或者“--file”指定 make 读取 makefile 的文件时,make 就不再自动查找这三个标准命
名的 makefile 文件。

---
**注释:通过命令指定目标使用make的隐含规则:**  
**&emsp;&emsp;当前目录下不存在以“GNUmakefile”、
“makefile”、“Makefile”命名的任何文件,**  
**&emsp;&emsp;1. 当前目录下存在一个源文件foo.c的,我们可以使用“make foo.o”来使用make的隐含规
则自动生成foo.o。当执行“make foo.o”时。我们可以看到其执行的命令为:**  
&emsp;&emsp;&emsp;&emsp;	**cc –c –o foo.o foo.c**  
&emsp;&emsp;**之后,foo.o将会被创建或者更新。**  
&emsp;&emsp;**2. 如果当前目录下没有foo.c文件时,就是make对.o文件目标的隐含规则中依赖文件不存在。**    
**&emsp;&emsp;如果使用命令“make foo.o”时,将回到到如下提示:**  
**&emsp;&emsp;&emsp;&emsp;	make:\*\*\* No rule to make target ‘foo.o’. Stop.**  
**&emsp;&emsp;3. 如果直接使用命令“make”时,得到的提示信息如下:**  
**&emsp;&emsp;&emsp;&emsp;	make: \*\*\* No targets specified and no makefile found. Stop.**

---

## 3.3 包含其他makefile文件

&emsp;&emsp;本节我们讨论如何在一个 Makefile 中包含其它的 makefile 文件。Makefile 中包含
其它文件所需要使用的关键字是“include”,和 c 语言对头文件的包含方式一致。

&emsp;&emsp;“include”指示符告诉 make 暂停读取当前的 Makefile,而转去读取“include”
指定的一个或者多个文件,完成以后再继续当前 Makefile 的读取。Makefile 中指示符
“include”书写在独立的一行,其形式如下:
```makefile
include FILENAMES...
```
&emsp;&emsp;**FILENAMES**是shell所支持的文件名（可以使用通配符）。

&emsp;&emsp;指示符“include”所在的行可以一个或者多个空格(make程序在处理时将忽略这
些空格)开始,切忌不能以[Tab]字符开始(如果一行以[Tab]字符开始make程序将此行
作为一个命令行来处理)。指示符“include”和文件名之间、多个文件之间使用空格或
者[Tab]键隔开。行尾的空白字符在处理时被忽略。使用指示符包含进来的Makefile中,
如果存在变量或者函数的引用。它们将会在包含它们的Makefile中被展开(详细可参考
第六章 Makefile中的变量)。

&emsp;&emsp;来看一个例子,存在三个.mk 文件 a.mk、b.mk、c.mk,“$(bar)”被扩展为“bish
bash”。则
```makefile
include foo\*.mk $(bar)
```
等价于
```make
include foo a.mk b.mk c.mk bish bash
```

&emsp;&emsp;之前已经提到过 make 程序在处理指示符 include 时,将暂停对当前使用指示符
“include”的 makefile 文件的读取,而转去依此读取由“include”指示符指定的文件
列表。直到完成所有这些文件以后再回过头继续读取指示符“include”所在的 makefile
文件。

&emsp;&emsp;通常指示符“include”用在以下场合:  
　　1. 有多个不同的程序,由不同目录下的几个独立的Makefile来描述其重建规则。它
们需要使用一组通用的变量定义(可参考 6.5 如何设置变量 一节)或者模式
规则(可参考 10.5 模式规则 一节)。通用的做法是将这些共同使用的变量或
者模式规则定义在一个文件中(没有具体的文件命名限制),在需要使用的
Makefile中使用指示符“include”来包含此文件。  
　　2. 当根据源文件自动产生依赖文件时;我们可以将自动产生的依赖关系保存在另
外一个文件中,主Makefile使用指示符“include”包含这些文件。这样的做法
比直接在主Makefile中追加依赖文件的方法要明智的多。其它版本的make已经
使用这种方式来处理。(参考 4.14 自动产生依赖 一节)

　　如果指示符 “ include ” 指定的文件不是以斜线开始(绝对路径,如
/usr/src/Makefile...),而且当前目录下也不存在此文件; make将根据文件名试图在以下
几个目录下查找:首先,查找使用命令行选项“-I”或者“--include-dir”(参考 9.7make
的命令行选项 一节)指定的目录,如果找到指定的文件,则使用这个文件;否则继续
依此搜索以下几个目录(如果其存在):“/usr/gnu/include”、“/usr/local/include”和“/usr/include”

　　当在这些目录下都没有找到“include”指定的文件时,make将会提示一个包含文
件未找到的告警提示,但是不会立刻退出。而是继续处理Makefile的后续内容。当完成
读取整个Makefile后,make将试图使用规则来创建通过指示符“include”指定的但未
找到的文件(参考 3.7 makefile文件的重建 一节),当不能创建它时(没有创建这个文
件的规则),make将提示致命错误并退出。会输出类似如下错误提示:
```makefile
Makefile: 错误的行数:未找到文件名:提示信息( No such file or directory )
Make : *** No rule to make target ‘<filename>’. Stop
```
　　通常我们在 Makefile 中可使用“-include”来代替“include”,来忽略由于包含文
件不存在或者无法创建时的错误提示(“-”的意思是告诉 make,忽略此操作的错误。
make 继续执行)。像下边那样:
```makefile
-include FILENAMES...
```
　　使用这种方式时,当所要包含的文件不存在时不会有错误提示、 make 也不会退出;
除此之外,和第一种方式效果相同。以下是这两种方式的比较:
使用“include FILENAMES...”,make 程序处理时,如果“FILENAMES”列表
中的任何一个文件不能正常读取而且不存在一个创建此文件的规则时 make 程序将会
提示错误并退出。

　　使用“\-include FILENAMES...”的情况是,当所包含的文件不存在或者不存在一个规则去创建它,make程序会继续执行,只有真正由于不能正确完成终极目标的重建
时(某些必需的目标无法在当前已读取的 makefile 文件内容中找到正确的重建规则),
才会提示致命错误并退出。

　　为了和其它的 make 程序进行兼容。也可以使用“sinclude”来代替“-include”
(GNU 所支持的方式)。

## 3.4 变量 MAKEFILES
　　如果在当前环境定义了一个“MAKEFILES”环境变量,make执行时首先将此变量的值作为需要读入的Makefile文件,多个文件之间使用空格分开。类似使用指示符
“include”包含其它Makefile文件一样,如果文件名非绝对路径而且当前目录也不存在
此文件,make会在一些默认的目录去寻找(参考 3.3 包含其它makefile文件 一节)。

它和使用“include”的区别:  
1. 环境变量指定的 makefile 文件中的“目标”不会被作为 make 执行的“终极目
标”。就是说,这些文件中所定义规则的目标,make 不会将其作为“终极目标”
来看待。如果在 make 的工作目录下没有一个名为“Makefile”、“makefile”或
者“GNUmakefile”的文件, make 同样会提示“make: \*** No targets specified
and no makefile found. Stop.”;而在 make 的工作目录下存在这样一个文件
(“Makefile”、“makefile”或者“GNUmakefile”),那么 make 执行时的“终
极目标”就是当前目录下这个文件中所定义的“终极目标”。
2. 环境变量所定义的文件列表,在执行 make 时,如果不能找到其中某一个文件
(不存在或者无法创建)。make 不会提示错误,也不退出。就是说环境变量
“MAKEFILES”定义的包含文件是否存在不会导致 make 错误(这是比较隐蔽
的地方)。
3. make 在执行时,首先读取的是环境变量“MAKEFILES”所指定的文件列表,
之后才是工作目录下的 makefile 文件,“include”所指定的文件是在 make 发
现此关键字的时、暂停正在读取的文件而转去读取“include”所指定的文件。

　　变量“MAKEFILES”主要用在“make”的递归调用过程中的的通信(参考5.6 make
的递归执行 一节)。实际应用中很少设置此变量。因为一旦设置了此变量,在多级make
调用时;由于每一级make都会读取“MAKEFILES”变量所指定的文件,将导致执行出
现混乱(这可能不是你想看到的执行结果)
。不过,我们可以使用此环境变量来指定一
个定义了通用“隐含规则”和变量的文件,比如设置默认搜索路径(可参考4.5 目录搜
索 一节);通过这种方式设置的“隐含规则”和定义的变量可以被任何make进程使用
(有点象C语言中的全局变量)。

　　也有人想让 login 程序自动的在自己的工作环境中设置此环境变量,编写的
Makefile 建立在此环境变量的基础上。此想法可以肯定地说不是一个好主意。规劝大家
千万不要这么干,否则你所编写的 Makefile 在其人的工作环境中肯定不能正常工作。

　　因为别人的工作环境中可能没有设置相同的环境变量“MAKEFILES”。
推荐的做法实:在需要包含其它 makefile 文件时使用指示符“include”来实现。

## 3.5 变量 MAKEFILE_LIST
　　make 程序在读取多个 makefile 文件时,包括由环境变量“MAKEFILES”指定、
命令行指、当前工作下的默认的以及使用指示符“include”指定包含的,在对这些文
件进行解析执行之前 make 读取的文件名将会被自动依次追加到变量
“MAKEFILE_LIST”的定义域中。

　　这样我们就可以通过测试此变量的最后一个字来获取当前 make 程序正在处理的
makefile 文件名。具体地说就是在一个 makefile 文件中如果使用指示符“include”包
含另外一个文件之后,变量“MAKEFILE_LIST”的最后一个字只可能是指示符“include”
指定所要包含的那个文件的名字。一个 makefile 的内容如下:

```makefile
name1 := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
include inc.mk
name2 := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
all:
	@echo name1 = $(name1)
	@echo name2 = $(name2)
```
　　执行make，则看到的将是如下的结果：
```makefile
name1 = Makefile
name2 = inc.mk
```
　　此例子中涉及到了 make 的函数的和变量定义的方式,这些将在后续的章节中有详
细的讲述。

## 3.6 其他特殊变量

　　GNUmake支持一个特殊的变量,此变量不能通过任何途经给它赋值。它被展开为
一个特定的值。一个重要的特殊的变量是“.VARIABLES”。它被展开以后是此引用点
之前、makefile文件中所定义的所有全局变量列表。包括:空变量(未赋值的变量)和
,但不包含目标指定的变量,目标指定变
make的内嵌变量(参考10.3 隐含变量 一节)
量值在特定目标的上下文有效。关于目标变量可参考 6.10 目标指定变量 一节


## 3.7 makefile文件的重建

　　Makefile 可由其它文件生成,例如 RCS 或 SCCS 文件。如果 Makefile 由其它文
件重建,那么在 make 在开始解析这个 Makefile 时需要重新读取更新后的 Makefile、
而不是之前的 Makefile。make 的处理过程是这样的:

　　make 在读入所有 makefile 文件之后,首先将所读取的每个 makefile 作为一个目
标,寻找更新它们的规则。如果存在一个更新某一个 makefile 文件明确规则或者隐含
规则,就去更新对应的 makefile 文件。完成对所有的 makefile 文件的更新之后,如果
之前所读取任何一个 makefile 文件被更新,那么 make 就清除本次执行的状态重新读
取一遍所有的 makefile 文件(此过程中,同样在读取完成以后也会去试图更新所有的
已经读取的 makefile 文件,但是一般这些文件不会再次被重建,因为它们在时间戳上
已经是最新的)。读取完成以后再开始解析已经读取的 makefile 文件并开始执行必要
的动作。

　　实际应用中,我们会明确给出makefile文件,而并不需要来由make自动重建它们。
但是make在每一次执行时总会自动地试图重建那些已经存在的makefile文件,如果需
要处于效率考虑,可以采用一些办法来避免make在执行过程时查找重建makefile的隐
含规则。例如我们可以书写一个明确的规则,以makefile文件作为目标,规则的命令定
义为空。(参考 5.8 空命令 一节)

　　Makefile规则中,如果使用一个没有依赖只有命令行的双冒号规则去更新一个文
件,那么每次执行make时,此规则的目标文件将会被无条件的更新(此规则定义的命
令会被无条件执行)。如果这样一个规则的目标是makefile文件,那么执行make时,
这个makefile文件(双冒号规则的目标)就会被无条件更新,而使得make的执行陷入
到一个死循环(此makefile文件被不断的更新、重新读取、更新再重新读取的过程)。
为了防止这种情况的发生,make在遇到一个目标是makefile文件的双冒号规则时,将
忽略对这个规则的执行(其中包括了使用“MAKEFILES”指定、命令行选项指定、指
示符“include”指定的需要make读取的所有makefile文件中定义的这一类双冒号规则)。
执行 make 时,如果没有使用“-f(--file)”选项指定一个文件,make 程序将读
取缺省的文件。和使用“-f(--file)”选项不同,make 无法确定工作目录下是否存在
缺省名称的 makefile 文件。如果缺省 makefile 文件不存在,但可以通过一个规则来创
建它(此规则是隐含规则),则会自动创建缺省 makefile 文件,之后重新读取它并开
始执行。

　　因此,如果在当前目录下不存在一个缺省的 makefile 文件,make 将会按照搜索
makefile 文件的名称顺序去试图创建它,直到创建成功或者超越其缺省的命名顺序。需
要明确的一点是:执行 make 时,如果不能成功地创建缺省的 makefile 文件,并不一
定会导致错误。一个存在(缺省命名的或者可被创建的)的 makefile 文件并不是 make
正确运行的前提(关于这一点大家会在后续的阅读过程中体会到)。
当使用“-t(--touch)”选项来更新 Makefile 的目标文件(更新规则目标文件的时
间戳)时,对于哪些是 makefile 文件的目标是无效的,这些目标文件(makefile 文件)
的时间戳并不会被更新。就是说即使在执行 make 时使用了选项“-t”,那些目标是
makefile 文件的规则同样也会被执行(重建这些 makefile 文件,而其它的规则不会被
执行, make 只是简单的更新规则目标文件的时间戳);类似还有选项“-q (—question)”
和“-n(—just-print) ”,这主要是因为一个过时的 makefile 文件对其它目标的重建
规则在当前看来可能是错误的。

　　正因为如此,执行命令“make –f mfile –n foo”首先会试图重建“mfile 文件”、
并重新读取它,之后会打印出更新目标“foo”所要执行的命令(但不会真正的执行这
些命令)。在这种情况时,如果不希望重建 makefile 文件。我们需要在执行 make 时,
在命令行中将这个 makefile 文件作为一个最终目标,这样选项“–t”和其它的选项就对
这个 makefile 文件目标有效,防止执行这个 makefile 作为目标的规则(如果是“-t”参
数,则是简单的更新这个 makefile 文件的时间戳)。同样,命令“make –f mfile –n mfile
foo”会读取文件“mfile”,打印出重建文件“mfile”的命令、重建“foo”的命令而实
际不执行任何命令。并且所打印的用于更新“foo”目标的命令是选项“-f”指定的、没
有被重建的“mfile”文件中所定义的命令。

## 3.8 重载另外一个makefile

　　有些情况下,存在两个比较类似的makefile文件。其中一个(makefile-A)需要使
用另外一个(makefile-B)中所定义的变量和规则。通常我们会想到在“makefile-A”
中使用指示符“include”包含“makefile-B”来达到目的。但使用这种方式,如果在两
个makefile文件中存在相同目标,而在不同的文件中其描述规则使用不同的命令。这
样,相同的目标文件就同时存在两个不同的规则命令,这是makefile所不允许的。遇
到这种情况,使用指示符“include”显然是行不通的。GNUmake提供另外一种途径
来实现此目的。具体的做法如下:

　　在需要包含的makefile文件(makefile-A)中,定义一个称之为“所有匹配模式”
(参考 10.5 模式规则 一节)的规则,它用来述那些在“makefile-A”中没有给出明
确创建规则的目标的重建规则。就是说,如果在当前makefile文件中不能找到重建一个
目标的规则时,就使用“所有匹配模式”所在的规则来重建这个目标。

　　看一个例子,如果存在一个命名为“Makefile”的 makefile 文件,其中描述目标“foo”
的规则和其他的一些规,我们也可以书写一个内容如下命名为“GNUmakefile”的文件。
```makefile
#sample GNUmakefile
foo:
	frobnicate > foo
%: force
	@$(MAKE) -f Makefile $@
force: ;
```
　　执行命令“make foo”,make 将使用工作目录下命名为“GNUmakefile”的文件
并执行目标“foo”所在的规则,创建目标“foo”的命令是:“frobnicate > foo”。如
果执行另外一个命令“make bar”,因为在“GUNmakefile”中没有此目标的更新规
则。make 将使用“所有匹配模式”规则,执行命令“$(MAKE) -f Makefile bar”。如
果文件“Makefile”中存在此目标更新规则的定义,那么这个规则会被执行。此过程同
样适用于其它 “GNUmakefile”中没有给出的目标更新规则。此方式的灵活之处在于:
如果在“Makefile”文件中存在同样一一个目标“foo”的重建规则,由于 make 执行时
首先读取文件“GUNmakefile”并在其中能够找到目标“foo”的重建规则,所以 make
就不会去执行这个“所有模式匹配规则”(上例中目标“%”所在的规则)。这样就避
免了使用指示符“include”包含一个 makefile 文件时所带来的目标规则的重复定义问
题。

　　此种方式,模式规则的模式只使用了单独的“%”(我们称他为“所有模式匹配规
则”),它可以匹配任何一个目标;它的依赖是“force”,保证了即使目标文件已经
存在也会执行这个规则(文件已存在时,需要根据它的依赖文件的修改情况决定是否需
要重建这个目标文件);“force”规则中使用空命令是为了防止 make 程序试图寻找
一个规则去创建目标“force”时,又使用了模式规则“%: force”而陷入无限循环。

## 3.9 make如何解析makefile文件

　　GUN make 的执行过程分为两个阶段。

　　第一阶段:读取所有的 makefile 文件(包括“MAKIFILES”变量指定的、指示符
“include”指定的、以及命令行选项“-f(--file)”指定的 makefile 文件),内建所有的
变量、明确规则和隐含规则,并建立所有目标和依赖之间的依赖关系结构链表。

　　在第二阶段:根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新,
并使用对应的规则来重建这些目标。

　　理解 make 执行过程的两个阶段是很重要的。它能帮助我们更深入的了解执行过程
中变量以及函数是如何被展开的。变量和函数的展开问题是书写 Makefile 时容易犯错
和引起大家迷惑的地方之一。本节将对这些不同的结构的展开阶段进行简单的总结(明
确变量和函数的展开阶段,对正确的使用变量非常有帮助)
。首先,明确以下基本的概
念;在 make 执行的第一阶段中如果变量和函数被展开,那么称此展开是“立即”的,
此时所有的变量和函数被展开在需要构建的结构链表的对应规则中(此规则在建立链表
是需要使用)。其他的展开称之为“延后”的。这些变量和函数不会被“立即”展开,
而是直到后续某些规则须要使用时或者在 make 处理的第二阶段它们才会被展开。

　　可能现在讲述的这些还不能完全理解。不过没有关系,通过后续章节内容的学习,
我们会一步一步的熟悉 make 的执行过程。学习过程中可以回过头来参考本节的内容。
相信在看完本书之后,会对 make 的整个过程有全面深入的理解。

### 3.9.1 变量取值

　　变量定义解析的规则如下：
```makefile
IMMEDIATE = DEFERRED
IMMEDIATE ?= DEFERRED
IMMEDIATE := IMMEDIATE
IMMEDIATE += DEFERRED or IMMEDIATE
define IMMEDIATE
	DEFERRED
Endef
```
　　当变量使用追加符(+=)时,如果此前这个变量是一个简单变量(使用 :=定义的)
则认为它是立即展开的,其它情况时都被认为是“延后”展开的变量。

### 3.9.2 条件语句

　　所有使用到条件语句在产生分支的地方,make 程序会根据预设条件将正确地分支
展开。就是说条件分支的展开是“立即”的。其中包括:
“ifdef”、“ifeq”、“ifndef”和
“ifneq”所确定的所有分支命令。

### 3.9.3 规则的定义
　　所有的规则在 make 执行时,都按照如下的模式展开:
```makefile
IMMEDIATE : IMMEDIATE ; DEFERRED
	DEFERRED
```

　　其中,规则中目标和依赖如果引用其他的变量,则被立即展开。而规则的命令行中
的变量引用会被延后展开。此模板适合所有的规则,包括明确规则、模式规则、后缀规
则、静态模式规则

## 3.10 总结

　　make的执行过程如下：
1. 依次读取变量“MAKEFILES”定义的 makefile 文件列表
2. 读取工作目录下的 makefile 文件(根据命名的查找顺序“GNUmakefile”,
“makefile”,“Makefile”,首先找到那个就读取那个)
3. 依次读取工作目录 makefile 文件中使用指示符“include”包含的文件
4. 查找重建所有已读取的 makefile 文件的规则(如果存在一个目标是当前读取的
某一个 makefile 文件,则执行此规则重建此 makefile 文件,完成以后从第一步
开始重新执行)
5. 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行
分支
6. 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表
7. 执行除“终极目标”以外的所有的目标的规则(规则中如果依赖文件中任一个
文件的时间戳比目标文件新,则使用规则所定义的命令重建目标文件)
8. 执行“终极目标”所在的规则

---
说明:  
执行一个规则的过程是这样的:

  对于一个存在的规则(明确规则和隐含规则)首先,make程序将比较目标文件和所有的依赖文
件的时间戳。如果目标的时间戳比所有依赖文件的时间戳更新(依赖文件在上一次执行make之后没
有被修改),那么什么也不做。否则(依赖文件中的某一个或者全部在上一次执行make后已经被修
改过),规则所定义的重建目标的命令将会被执行。这就是make工作的基础,也是其执行规制所定
义命令的依据。(后续讨论规则时将会对此详细地说明)

---
