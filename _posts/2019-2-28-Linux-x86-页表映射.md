---
layout: post
title: "Linux-x86-页表映射"
subtitle: '分析arm页表映射过程'
author: "404"
header-style: text
tags:
  - Linux
  - x86
  - Memory
---

>此篇文章为原创，转载请注明出处。

了解操作系统的人都应该知道，系统对内存的管理是从段式转换到页式的。对内存进行页式管理让系统对内存利用率更高，更便于管理，这里就不进行段式介绍了。这篇文章对页式管理也以32位线性地址为基础来说明，64位的看情况介绍，大致原理都差不多。
在x86结构下，系统将32位地址分为如下几个部分：
![avatar](/img/in-post/Linux/201922801001.png)
这是一个二级页表，目录项用了10位，页表项用了10位，最后12位用来用作最终寻址的偏移地址，整个寻址过程如下：
![avatar](/img/in-post/Linux/201922801002.png)
这里的目录项，页表项都是偏移地址，整个过程如下：
- 从CR3取得页面目录的基地址
- 以线性地址中的dir位段为下标，在目录中取得相应页面表的基地址
- 以线性地址中的page位段为下标，在所得到的页面表中取得相应的页面描述符
- 将页面描述项中给出的页面基地址与线性地址中的offset位段相加得到物理地址

在这里有很多`巧合`，我们管理内存是细分为页面来管理，一般把一个页面大小定为4K，页面此时是操作系统操作的最小单元。比如操作系统要取某一个地址`0xCf03e12`，这里并不是单单把这个地址数据取出，操作系统还有一个`局部性原理`，往往操作一个地址的时候，通常后面连续的地址也会操作，这样如果再重新通过CPU发指令再去地址中取会比较耗费时间，由此一次就取出`0xCf03e12`这个地址所在页面的全部到缓存中，这样待后续操作完成后，再讲整个页面重新写回到内存，期间肯定会进行读写等一些安全性判断，这里就不细致介绍了，如此操作大大的节省了计算机运行时间。

我们说到一个页面大小一般是4K，此时这里dir有10位，可寻址范围是1K；page项是10位，可寻址范围是1K；组合起来总共的寻址范围为1M，一个页面大小为4K，那么总共寻址大小也就为4G，恰好对应32位地址线的寻址。

如上所述，目录项中含有指向一个页面表的指针，而页面表项中则含有指向一个页面起始地址的指针。由于页面表和页面的起始地址都总是在4k字节的边界上，这些指针的低12位永远是0。这样在目录项和页表项中都只要有20位用于指针就够了，而余下的12位则可以用于控制或其他目的。目录结构图如下：
![avatar](/img/in-post/Linux/201922801003.png)
用数据结构说明，如下：
```c
typedef struct {
  unsigned int ptba:20;    //页表基地址高20位
  unsigned int avail;      //供系统程序员使用
  unsigned int g:1;       //global, 全局性页面
  unsigned int ps:1;      //页面大小，0表示4k字节
  unsigned int reserved:1; //保留，永远为0
  unsigned int a:1;       //accessed, 已被访问过
  unsigned int pcd:1;     //关闭缓冲区
  unsigned int pwt:1;     //write-through,用于缓冲存储器
  unsigned int u_s:1;      //为0时表示系统权限，为1时表示用户权限
  unsigned int r_w:1;     //只读或可写
  unsigned int p:1;     //为0时表示相应的页面不存在于内存中
}
```
在地址中用这些多出来的位来控制页面，那么就可以更精细化的来管理页面。
