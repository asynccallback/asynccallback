---
layout: post
title: "Uboot-Nandflash进阶＜一＞"
subtitle: Uboot-Nandflash进阶分析
author: "404"
header-style: text
tags:
  - Linux
  - Arm
  - Uboot
  - NANDflash
---
>本篇文章转载自[【详解】如何编写Linux下Nand Flash驱动](https://www.crifan.com/files/doc/docbook/linux_nand_driver/release/html/linux_nand_driver.html),写的挺好

# 1. 一些相关的名词的解释

## 1.1 Non-Volatile Memory非易失性存储器
　　NVM，即NV （RAM）Memory，断电数据也不会丢失的存储器，比如Nand Flash，Nor Flash，硬盘等等。于此相对的是，断电了数据会丢失的存储器，比如DRAM等。

## 1.2 OTP一次性可编程存储器
　　OTP，一种非易失性存储器，但是只允许一次性写入数据，写入（或称烧写）数据之后，就不能修改了。

　　OTP的好处或者说用途是，常用于写入一些和芯片相关的一些特定数据，用于加密的一些数据等。

　　与一次性写入数据的OTP相对应的是，像Nand Flash，硬盘等存储器，可以被多次写入数据。只要硬盘这类的存储器没坏，你高兴写入几次就写入几次，而OTP就只能写入一次，就没法再修改里面的数据了。

## 1.3 NDA 保密协议
　　NDA，中文可以翻译为，非公开协议，保密协议。

　　说白了，还是一种协议，常用于这种情况：   
　　某家厂商的某种技术或资料，是保密的，不希望公开的。   
　　但是呢，如果你要用他家的芯片啊之类的东西，在开发过程中，又必须得到对应的技术和资料，才能开发产品，所以，他就会要求和你签订这样的NDA协议，意思就是，你可以用我的技术和资料，但是你不能公开给（我未授权的）其他人。如果非法泄露我的机密技术，那我肯定要走法律程序控告你，之类的。

## 1.4 Datasheet数据手册和Specification规范
　　英文datasheet，中文一般翻译为数据手册。   
　　指的是对应某个硬件，多为芯片，的功能说明，定义了如何操作该硬件，达到你要的功能，这其中主要包括芯片中的相关寄存器的定义，如何发送命令，发送什么命令，以此来操作此硬件等等。

　　而英文Specification，引文常缩写为Spec.，中文一般翻译为规范。   
　　多指某个组织（盈利的或非盈利的），定义了一些规矩，如果你要用某种东西，在计算机领域，常常指的是某硬件和相关的软件协议，就要按照此规矩来操作，人家这个组织呢，保证你只要实现了此规范，设备就能按照你所期望的运行，能够实现对应的功能，而你的芯片实现了此规范，就叫做，是和此规范兼容（compatible）的。

## 1.5 Nand Flash相关的一些名词解释

### 1.5.1 (Bad) Block Management（坏）块管理
　　Nand Flash由于其物理特性，只有有限的擦写次数，超过那个次数，基本上就是坏了。在使用过程中，有些Nand Flash的block会出现被用坏了，当发现了，要及时将此block标注为坏块，不再使用。

　　于此相关的管理工作，属于Nand Flash的坏块管理的一部分工作。

### 1.5.2 Wear-Leveling负载平衡
　　Nand Flash的block的管理，还包括负载平衡。

　　正是由于Nand Flash的block，都是有一定寿命限制的，所以如果你每次都往同一个block擦除然后写入数据，那么那个block就很容易被用坏了，所以我们要去管理一下，将这么多次的对同一个block的操作，平均分布到其他一些block上面，使得在block的使用上，相对较平均，这样相对来说，可以更能充分利用Nand Flash。

　　关于wear-leveling这个词，再简单解释一下，wear就是穿（衣服）等，用（东西）导致磨损，而leveling就是使得均衡，所以放在一起就是，使得对于Nand Flash的那么多的block的使用磨损，相对均衡一些，以此延长Nand Flash的使用寿命或者说更加充分利用Nand Flash。

### 1.5.3 ECC错误校验码
　　Nand Flash物理特性上使得其数据读写过程中会发生一定几率的错误，所以要有个对应的错误检测和纠正的机制，于是才有此ECC，用于数据错误的检测与纠正。Nand Flash的ECC，常见的算法有海明码和BCH，这类算法的实现，可以是软件也可以是硬件。不同系统，根据自己的需求，采用对应的软件或者是硬件。

　　相对来说，硬件实现这类ECC算法，肯定要比软件速度要快，但是多加了对应的硬件部分，所以成本相对要高些。如果系统对于性能要求不是很高，那么可以采用软件实现这类ECC算法，但是由于增加了数据读取和写入前后要做的数据错误检测和纠错，所以性能相对要降低一些，即Nand Flash的读取和写入速度相对会有所影响。

　　其中，Linux中的软件实现ECC算法，即NAND_ECC_SOFT模式，就是用的对应的海明码。

　　而对于目前常见的MLC的Nand Flash来说，由于容量比较大，动辄2GB，4GB，8GB等，常用BCH算法。BCH算法，相对来说，算法比较复杂。

　　笔者由于水平有限，目前仍未完全搞懂BCH算法的原理。

　　BCH算法，通常是由对应的Nand Flash的Controller中，包含对应的硬件BCH ECC模块，实现了BCH算法，而作为软件方面，需要在读取数据后，写入数据之前，分别操作对应BCH相关的寄存器，设置成BCH模式，然后读取对应的BCH状态寄存器，得知是否有错误，和生成的BCH校验码，用于写入。

　　其具体代码是如何操作这些寄存器的，由于是和具体的硬件，具体的nand flash的controller不同而不同，无法用同一的代码。如果你是nand flash驱动开发者，自然会得到对应的起nand flash的controller部分的datasheet，按照手册说明，去操作即可。

　　不过，额外说明一下的是，关于BCH算法，往往是要从专门的做软件算法的厂家购买的，但是Micron之前在网上放出一个免费版本的BCH算法。

# 2. 硬件特性

## 2.1 什么是Flash
　　Flash全名叫做Flash Memory，从名字就能看出，是种数据存储设备，存储设备有很多类，Flash属于非易失性存储设备(Non-volatile Memory Device)，与此相对应的是易失性存储设备(Volatile Memory Device)。关于什么是非易失性/易失性，从名字中就可以看出，非易失性就是不容易丢失，数据存储在这类设备中，即使断电了，也不会丢失，这类设备，除了Flash，还有其他比较常见的入硬盘，ROM等，与此相对的，易失性就是断电了，数据就丢失了，比如大家常用的内存，不论是以前的SDRAM，DDR SDRAM，还是现在的DDR2，DDR3等，都是断电后，数据就没了。

## 2.1.1 Flash的硬件实现机制
　　Flash的内部存储是MOSFET，里面有个悬浮门(Floating Gate)，是真正存储数据的单元。

　　在Flash之前，紫外线可擦除(uv-erasable)的EPROM，就已经采用了Floating Gate存储数据这一技术了。
![avatar](/img/in-post/Linux/201933101001.jpg)
　　数据在Flash内存单元中是以电荷(electrical charge) 形式存储的。存储电荷的多少，取决于图中的外部门（external gate）所被施加的电压，其控制了是向存储单元中冲入电荷还是使其释放电荷。而数据的表示，以所存储的电荷的电压是否超过一个特定的阈值Vth来表示，因此，Flash的存储单元的默认值，不是0（其他常见的存储设备，比如硬盘灯，默认值为0），而是1，而如果将电荷释放掉，电压降低到一定程度，表述数字0。

## 2.2 什么是Nand Flash
　　Flash主要分两种，Nand Flash和nor flash。   
1. Nor的成本相对高，容量相对小，比如常见的只有128KB，256KB，1MB，2MB等等，优点是读写数据时候，不容易出错。所以在应用领域方面，Nor Flash比较适合应用于存储少量的代码。   
2. Nand flash成本相对低，说白了就是便宜，缺点是使用中数据读写容易出错，所以一般都需要有对应的软件或者硬件的数据校验算法，统称为ECC。但优点是，相对来说容量比较大，现在常见的Nand Flash都是1GB，2GB，更大的8GB的都有了，相对来说，价格便宜，因此适合用来存储大量的数据。其在嵌入式系统中的作用，相当于PC上的硬盘，用于存储大量数据。

　　所以，一个常见的应用组合就是，用小容量的Nor Flash存储启动代码，比如uboot，用大容量的Nand Flash做整个系统和用户数据的存储。

　　而一般的嵌入式平台的启动流程也就是，系统从装有启动代码的Nor Flash启动后，初始化对应的硬件，包括SDRAM等，然后将Nand Flash上的Linux 内核读取到内存中，做好该做的事情后，就跳转到SDRAM中去执行内核了，然后内核解压（如果是压缩内核的话，否则就直接运行了）后，开始运行，在Linux内核启动最后，去Nand Flash上，挂载根文件，比如jffs2，yaffs2等，挂载完成，运行初始化脚本，启动consle交互，才允许你通过console和内核交互。至此完成整个系统启动过程。

　　而Nor Flash就分别存放的是Uboot，Nand Flash存放的是Linux的内核镜像和根文件系统，以及余下的空间分成一个数据区。

### 2.2.1 Nand Flash的详细分类
　　Nand Flash，按照硬件类型，可以分为

1. Bare NAND chips：裸片。单独的Nand Flash芯片。
2. SmartMediaCards：裸片+一层薄塑料。常用于数码相机和MP3播放器中。之所以称smart，是由于其软件smart，而不是硬件本身有啥smart之处。
3. DiskOnChip：裸片+glue logic。glue logic=硬件ECC产生器+用于静态的nand 芯片控制的寄存器+直接访问一小片地址窗口，那块地址中包含了引导代码的stub桩，其可以从Nand Flash中拷贝真正的引导代码。

## 2.3 SLC和MLC的实现机制
　　Nand Flash按照内部存储数据单元的电压的不同层次，也就是单个内存单元中，是存储1位数据，还是多位数据，可以分为SLC和MLC。

### 2.3.1 SLC（Single Level Cell）
　　单个存储单元，只存储一位数据，表示1或0。

　　就是上面介绍的，对于数据的表示，单个存储单元中内部所存储电荷的电压，和某个特定的阈值电压Vth，相比，如果大于此Vth值，就是表示1，反之，小于Vth，就表示0。

　　对于Nand Flash的数据的写入1，就是控制External Gate去充电，使得存储的电荷够多，超过阈值Vth，就表示1了。而对于写入0，就是将其放电，电荷减少到小于Vth，就表示0了。

　　关于为何Nand Flash不能从0变成1，我的理解是，物理上来说，是可以实现每一位的，从0变成1的，但是实际上，对于实际的物理实现，出于效率的考虑，如果对于，每一个存储单元都能单独控制，即，0变成1就是，对每一个存储单元单独去充电，所需要的硬件实现就很复杂和昂贵，同时，所进行对块擦除的操作，也就无法实现之前所说的的，Flash的速度，即一闪而过的速度了，也就失去了Flash的众多特性了。

### 2.3.2 MLC（Multi Level Cell）
　　与SLC相对应的，就是单个存储单元，可以存储多个位，比如2位，4位等。其实现机制，说起来比较简单，就是通过控制内部电荷的多少，分成多个阈值，通过控制里面的电荷多少，而达到我们所需要的存储成不同的数据。比如，假设输入电压是Vin＝4V（实际没有这样的电压，此处只是为了举例方便），那么，可以设计出2的2次方＝4个阈值， 1/4 的Vin＝1V，2/4的Vin＝2V，3/4的Vin＝3V，Vin＝4V，分别表示2位数据00，01，10，11，对于写入数据，就是充电，通过控制内部的电荷的多少，对应表示不同的数据。

　　对于读取，则是通过对应的内部的电流（与Vth成反比），然后通过一系列解码电路完成读取，解析出所存储的数据。这些具体的物理实现，都是有足够精确的设备和技术，才能实现精确的数据写入和读出的。

　　单个存储单元可以存储2位数据的，称作2的2次方＝4 Level Cell，而不是2 Level Cell，关于这点，之前看Nand flash的数据手册（datasheet）的时候，差点搞晕了。

　　同理，对于新出的单个存储单元可以存储4位数据的，称作 2的4次方＝16 Level Cell。

### 2.3.3 关于如何识别SLC还是MLC
　　Nand Flash设计中，有个命令叫做Read ID，读取ID，意思是读取芯片的ID，就像大家的身份证一样，这里读取的ID中，是读取好几个字节，一般最少是4个，新的芯片，支持5个甚至更多，从这些字节中，可以解析出很多相关的信息，比如此Nand Flash内部是几个芯片（chip）所组成的，每个chip包含了几片（Plane），每一片中的页大小，块大小，等等。在这些信息中，其中有一个，就是识别此flash是SLC还是MLC。下面这个就是最常见的Nand Flash的datasheet中所规定的，第3个字节，3rd byte，所表示的信息，其中就有SLC/MLC的识别信息：
![avatar](/img/in-post/Linux/201933101002.png)

## 2.4 Nand Flash数据存储单元的整体架构

　　简单说就是，常见的Nand Flash，内部只有一个chip，每个chip只有一个plane。

　　而有些复杂的，容量更大的Nand Flash，内部有多个chip，每个chip有多个plane。这类的Nand Flash，往往也有更加高级的功能，比如下面要介绍的Multi Plane Program和Interleave Page Program等。

　　概念上，由大到小来说，就是：   
　　Nand Flash ⇒ Chip ⇒ Plane ⇒ Block ⇒ Page ⇒ oob

　　用图表来表示，更加易懂：
![avatar](/img/in-post/Linux/201933101003.png)
　　比如，型号为K9K8G08U0A这块Nand Flash（有时候也被称为此块chip芯片），其内部有两个K9F4G08U0A的chip，chip#1和chip#2，每个K9F4G08U0A的chip包含了2个Plane，每个Plane是2Gbbit，所以K9F4G08U0A的大小是2Gb×2 = 4Gb = 512MB，因此，K9K8G08U0A内部有2个K9F4G08U0A，或者说4个Plane，总大小是×256MB＝1GB。

　　用公式表示如下：   
　　**公式 1.1. K9K8G08U0A的物理结构所组成的总容量**   
　　K9K8G08U0A(这块Nand Flash)   
= 2 × K9F4G08U0A(K9F4G08U0A是chip，1 K9F4G08U0A = 2 Plane)   
　2 × 2个Plane   
= 4 Plane(1 Plane = 2048 Block)   
= 4 × 2048个Block(1 Block = 64 Page)   
= 4 × 2048 × 64Page(1 Page = 2KB)   
= 4 × 2048 × 64Page × 2KB   
= 4 × 2048 × 128KB(1 Block = 128KB)   
= 4 × 256MB(1 Plane = 2Gb = 256MB)   
= 2 × 512MB(1 K9F4G08U0A = 4Gb = 512MB)   
= 1GB(1 K9K8G08U0A = 1GB)   

　　而型号是K9WAG08U1A的Nand Flash，内部包含了2个K9K8G08U0A，所以，总容量是K9K8G08U0A的两倍＝1GB×2＝2GB，类似地K9NBG08U5A，内部包含了4个K9K8G08U0A，总大小就是4×1GB＝4GB。

　　下面详细介绍一下，Nand Flash的一个chip内部的硬件逻辑组织结构。

## 2.5 Nand Flash的物理存储单元的阵列组织结构

　　Nand Flash的内部组织结构，此处还是用图来解释，比较容易理解：
![avatar](/img/in-post/Linux/201933101004.png)

### 2.5.1 Block块
　　一个Nand Flash（的chip，芯片）由很多个块（Block）组成，块的大小一般是128KB，256KB，512KB，此处是128KB。其他的小于128KB的，比如64KB，一般都是下面将要介绍到的small block的Nand Flash。   
　　块Block，是Nand Flash的擦除操作的基本/最小单位。

### 2.5.2 Page页
　　每个块里面又包含了很多页（page）。每个页的大小，对于现在常见的Nand Flash多数是2KB，最新的Nand Flash的是4KB、8KB等，这类的页大小大于2KB的Nand Flash，被称作big block的Nand Flash，对应的发读写命令地址，一共5个周期(cycle)，而老的Nand Flash，页大小是256B，512B，这类的Nand Flash被称作small block，地址周期只有4个。   
　　页Page，是读写操作的基本单位。   
　　不过，也有例外的是，有些Nand Flash支持subpage（1/2页或1/4页）子页的读写操作，不过一般很少见。

### 2.5.3 oob / Redundant Area / Spare Area
　　每一个页，对应还有一块区域，叫做空闲区域（spare area）/冗余区域（redundant area），而Linux系统中，一般叫做OOB（Out Of Band），这个区域，是最初基于Nand Flash的硬件特性：数据在读写时候相对容易错误，所以为了保证数据的正确性，必须要有对应的检测和纠错机制，此机制被叫做EDC(Error Detection Code)/ECC（Error Code Correction, 或者 Error Checking and Correcting），所以设计了多余的区域，用于放置数据的校验值。   
　　Oob的读写操作，一般是随着页的操作一起完成的，即读写页的时候，对应地就读写了oob。   
　　关于oob具体用途，总结起来有：
1. 标记是否是坏快
2. 存储ECC数据
3. 存储一些和文件系统相关的数据。如jffs2就会用到这些空间存储一些特定信息，而yaffs2文件系统，会在oob中，存放很多和自己文件系统相关的信息。

## 2.6 Flash名称的由来
　　Flash的擦除操作是以block块为单位的，与此相对应的是其他很多存储设备，是以bit位为最小读取/写入的单位，Flash是一次性地擦除整个块：在发送一个擦除命令后，一次性地将一个block，常见的块的大小是128KB/256KB。。，全部擦除为1，也就是里面的内容全部都是0xFF了，由于是一下子就擦除了，相对来说，擦除用的时间很短，可以用一闪而过来形容，所以，叫做Flash Memory。所以一般将Flash翻译为 （快速）闪存。

## 2.7 Flash相对于普通设备的特殊性
　　根据上面提到过的，Flash最小操作单位，相对于普通存储设备，就显得有些特殊。

　　因为一般存储设备，比如硬盘或内存，读取和写入都是以位（bit）为单位，读取一个bit的值，将某个值写入对应的地址的位，都是可以按位操作的。

　　但是Flash由于物理特性，使得内部存储的数据，只能从1变成0，这点，这点可以从前面的内部实现机制了解到，对于最初始值，都是1，所以是0xFFFFFFFF，而数据的写入，即是将对应的变成0，而将数据的擦出掉，就是统一地，以block为单位，全部一起充电，所有位，都变成初始的1，而不是像普通存储设备那样，每一个位去擦除为0。而数据的写入，就是电荷放电的过程，代表的数据也从1变为了0。

　　所以，总结一下Flash的特殊性如下：
![avatar](/img/in-post/Linux/201933101005.png)

1. 之所以将写操作叫做编程，是因为flash是从之前的EPROM、EEPROM等继承发展而来，而之前的EEPROM，往里面写入数据，就叫做编程Program，之所以这么称呼，是因为其对数据的写入，是需要用电去擦除/写入的，所以叫做编程。
2. 对于目前常见的页大小是2K/4K的Nand Flash，其块的大小有128KB/256KB/512KB等。而对于Nor Flash，常见的块大小有64K/32K等。
3. 在写数据之前，要先擦除，内部就都变成0xFF了，然后才能写入数据，也就是将对应的位由1变成0。

## 2.8 Nand Flash的位反转特性
　　Nand Flash的位反转，也叫做位翻转，对应的英文表达有：Bit Flip=Bit Flipping=Bit-Flip=Bit twiddling。

　　Nand Flash由于本身硬件的内在特性，会导致（极其）偶尔的出现位反转的现象。

　　所谓的位反转，bit flip，指的是原先Nand Flash中的某个位，变化了，即要么从1变成0了，要么从0变成1了。

### 2.8.1 Nand Flash位反转的原因
　　Nand Flash的位反转现象，主要是由以下一些原因/效应所导致：
1. 漂移效应（Drifting Effects）   
漂移效应指的是，Nand Flash中cell的电压值，慢慢地变了，变的和原始值不一样了。
2. 编程干扰所产生的错误（Program-Disturb Errors）   
此现象有时候也叫做，过度编程效应（over-program effect）。   
对于某个页面的编程操作，即写操作，引起非相关的其他的页面的某个位跳变了。
3. 读操作干扰产生的错误（Read-Disturb Errors）   
此效应是，对一个页进行数据读取操作，却使得对应的某个位的数据，产生了永久性的变化，即Nand Flash上的该位的值变了。

### 2.8.2 Nand Flash位反转的影响
　　位反转，说白了，就是读取数据的时候，数据出错了。

　　因此，如果你读取的数据正好是属于某个重要的文件中的数据，比如系统的配置文件等，那么此时错了一位，都会导致系统出现异常，问题相对会很严重。

　　而如果此数据属于音视频流中的数据，那么此时即使错了一位，对整个音视频的播放产生的影响也很小，所以问题也不大。

### 2.8.3 Nand Flash位反转的类型和解决办法

　　对应的位反转的类型，有两种：   
1. 一种是nand flash物理上的数据存储的单元上的数据，是正确的，只是在读取此数据出来的数据中的某位，发生变化，出现了位反转，即读取出来的数据中，某位错了，本来是0变成1，或者本来是1变成0了。此处可以成为软件上位反转。此数据位的错误，当然可以通过一定的校验算法检测并纠正。
2. 另外一种，就是nand flash中的物理存储单元中，对应的某个位，物理上发生了变化，原来是1的，变成了0，或原来是0的，变成了1，发生了物理上的位的数据变化。此处可以成为硬件上的位反转。此错误，由于是物理上发生的，虽然读取出来的数据的错误，可以通过软件或硬件去检测并纠正过来，但是物理上真正发生的位的变化，则没办法改变了。不过个人理解，好像也是可以通过擦除Erase整个数据块Block的方式去擦除此错误，不过在之后的Nand Flash的使用过程中，估计此位还是很可能继续发生同样的硬件的位反转的错误。
以上两种类型的位反转，其实对于从Nand Flash读取出来的数据来说，解决其中的错误的位的方法，都是一样的，即通过一定的校验算法，常称为ECC，去检测出来，或检测并纠正错误。

　　如果只是单独检测错误，那么如果发现数据有误，那么再重新读取一次即可。

　　实际中更多的做法是，ECC校验发现有错误，会有对应的算法去找出哪位错误并且纠正过来。

　　其中对错误的检测和纠正，具体的实现方式，有软件算法，也有硬件实现，即硬件Nand Flash的控制器controller本身包含对应的硬件模块以实现数据的校验和纠错的
