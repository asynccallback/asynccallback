---
layout: post
title: "Arm基础知识——位置无关"
subtitle: Arm中位置无关位置相关的一些理解
author: "404"
header-style: text
tags:
  - Linux
  - Arm
  - Uboot
---

# 1. 位置无关相关概念
　　应用程序必须经过编译、汇编和链接后才变成可执行文件,在链接时,要对所有目标文件进行重定位(relocation),建立符号引用规则,同时为变量、函数等分配运行地址。当程序执行时,系统必须把代码加载到链接时所指定的地址空间,以保证程序在执行过程中对变量、函数等符号的正确引用,使程序正常运行。在具有操作系统的系统中,重定位过程由操作系统自动完成。

　　在设计Bootloader程序时,必须在裸机环境中进行,这时Bootloader映像文件的运行地址必须由程序员设定。通常情况下,将Bootloader程序下载到ROM的0x0地址进行启动,而在大多数应用系统中,为了快速启动,首先将Bootloader程序拷贝到SDRAM中再运行。一般情况下,这两者的地址并不相同,程序在SDRAM中的地址重定位过程必须由程序员完成。实际上,由于Bootloader是系统上电后要执行的第一段程序,Bootloader程序的拷贝和在这之前的所有工作都必须由其自身来完成,而这些指令都是在ROM中执行的。也就是说,这些代码即使不在链接时所指定的运行时地址空间,也可以正确执行。这就是位置无关代码,它是一段加载到任意地址空间都能正常执行的特殊代码。

　　位置无关代码常用于以下场合:
-程序在运行期间动态加载到内存;
-程序在不同场合与不同程序组合后加载到内存(如共享的动态链接库);
-在运行期间不同地址相互之间的映射(如Bootloader程序)。

　　虽然在用GCC编译时,使用-fPIC选项可为C语言产生位置无关代码,但这并不能修正程序设计中固有的位置相关性缺陷。特别是汇编语言代码,必须由程序员遵循一定的程序设计准则,才能保证程序的位置无关性。

# 2. ARM处理器的位置无关程序设计要点

　　ARM程序的位置无关可执行文件PIE(PositionIndependent Executable)包括位置无关代码PIC和位置无关数据PID(Position-IndependentData)两部分。

　　PID主要针对可读写数据段(.data段),其中保存已赋初值的全局变量。为实现其位置无关性,通常使用寄存器R9作为静态基址寄存器,使其指向该可读写段的首地址,并使用相对于基址寄存器的偏移量来对该段的变量进行寻址。这种方法常用于为可重入程序的多个实例产生多个独立的数据段。在程序设计中,一般不必考虑可读写段的位置无关性,这主要是因为可读写数据主要分配在SDRAM中。

　　PIC包括程序中的代码和只读数据(.text段),为保证程序能在ROM和SDRAM空间都能正确运行(如裸机状态下的Bootloader程序),必须采用位置无关代码程序设计。下面重点介绍PIC的程序设计要点。PIC遵循只读段位置无关ROPI(Read-Only PositionIndependence)的ATPCS(ARM-ThumbProcedureCallStandard)的程序设计规范:

## 2.1 程序设计规范1

　　引用同一ROPI段或相对位置固定的另一ROPI段中的符号时,必须是基于PC的符号引用,即使用相对于当前PC的偏移量来实现跳转或进行常量访问。

### 2.1.1 位置无关的程序跳转   
　　在ARM汇编程序中,使用相对跳转指令B/BL实现程序跳转。指令中所跳转的目标地址用基于当前PC的偏移量来表示,与链接时分配给地址标号的绝对地址值无关,因而代码可以在任何位置进行跳转,实现位置无关性。   
　　另外,还可使用ADR或ADRL伪指令将地址标号值读取到PC中实现程序跳转。这是因为ADR或ADRL等伪指令会被编译器替换为对基于PC的地址值进行操作,但这种方式所能读取的地址范围较小,并且会因地址值是否为字对齐而异。   
　　但在ARM程序中,使用LDR等指令直接将地址标号值读取到PC中实现程序跳转不是位置无关的。例如:   
```c
ldr PC, =main
```
　　上面的 LDR 汇编伪指令编译后的结果为:
```c
ldr PC, [PC,OFFSET _TO_LPOOL]
...
LPOOL DCD main
```
　　可见,虽然LDR是把基于PC的一个存储单元LPOOL的内容加载到PC中,但该存储单元中保存的却是链接时所决定的main函数入口的绝对地址,所以main函数实际所在的段不是位置无关。

### 2.1.2 LDR指令分析

　　在Arm体系中，LDR是可以作为真指令，也可以作为伪指令的，我们现在只分析伪指令。LDR伪指令将一个32位的常数或者一个地址值读取到寄存器中。语法格式如下：
```c
LDR{cond} register, = {expr|label-expr}
```
　　其中符号的说明如下：
- cond为可选的指令执行的条件。
- register为目标寄存器。
- expr为32位的常量。编译器将根据expr的取指情况，处理LDR伪指令如下。
  - 当expr表示的地址值没有超过MOV或MVN指令中地址的取指范围时，编译器调用合适的MOV或MVN指令代替该LDR伪指令。
  - 当expr表示的地址超过了MOV或MVN指令中的地址取指范围时，**编译器将该常数放在数据缓冲区中，同时用一条基于PC的LDR指令读取该常数**。
- label-expr为基于PC的地址表达式或者外部表达式。当label-expr为基于PC的地址表达式时，编译器将label-expr表示的数值放在数据缓冲区中，同时用一条基于PC的LDR指令读取该数值。当label-expr为外部表达式，或者非当前段的表达式时，汇编编译器将在目标文件中插入连接重定位伪操作，这样连接器将在连接时生成该地址。

　　使用说明：   
　　LDR伪指令主要有以下两种用途：
- 当需要读取到寄存器中的数据超过了MOV和MVN指令可以操作的范围时，可以使用LDR伪指令将该数据读取到寄存器中。
- 将一个基于PC的地址值或外部的地址值读入到寄存器中。由于这种地址值是在连接时确定的，所以这种代码不是位置无关的。同时LDR伪指令处的PC值到数据缓冲区中的目标数据所在地址的偏移量要小于4KB。

　　下面以这个例子来进行说明：
![avatar](/img/in-post/Linux/201932502001.png)
　　将其`objdump -D`之后的结果如下：
![avatar](/img/in-post/Linux/201932502002.png)

　　这里我们需要注意的是Arm体系的流水线指令结构，前面说过很多次了，这里就不再次说了。总体来说就是PC指向的是当前PC+8。
　　当我们`ldr r0, TEXT_BASE`时，对应的反汇编是`ldr r0, [pc, #-12]`。当前执行指令标号是4，这里PC-12实际上是`4+8-12`,等于0，实际上就指向TEXT_BASE标号0的位置。
　　当我们`ldr r0, =TEXT_BASE`时，对应的反汇编是：
```c
c:	e59f300c 	ldr	r3, [pc, #12]	; 20 <SDM+0x4>

0000001c <SDM>:
  1c:	15150000 	ldrne	r0, [r5, #-0]
  20:	00000000 	andeq	r0, r0, r0
  24:	0000001c 	andeq	r0, r0, ip, lsl r0
  28:	54541500 	ldrbpl	r1, [r4], #-1280	; 0x500
```
　　此时`PC,#12`对应的值为`c+c+8=0x20`,这个计算中，我们把相应的十进制转换为了十六进制，他对应的就是位置0x20，那么0x20里面存储的是什么呢？我们看到了是`0x00000000`，这里对应的就是TEXT_BASE标号地址，也就是说开辟了一个新地址，用这个新地址来存储TEXT_BASE标号。同理对于`ldr r4, =SDM`也是一样，可以自行分析。

　　理解了这些，我们再去看上面的`ldr pc, =main`就可以知道为什么他是位置相关的了。因为他会在数据缓冲区给main分配一个位置，来存储main的链接地址，而这个链接地址是在连接时就会确定，如果加载地址和链接地址不同的话，此时程序就会跑飞，这个地址就不是位置无关，而是位置相关的。

### 2.1.2 位置无关的常量访问

　　在应用程序中,经常要读写相关寄存器以完成必要的硬件初始化。为增强程序的可读性,利用EQU伪指令对一些常量进行赋值,但在访问过程中,必须实现位置无关性。下面以PXA270的GPIO初始化介绍位置无关的常量访问方法。
```c
GPIO_BASE EQU 0x40e00000 ; GPIO 基址寄存器地址
GPDR0 EQU 0x00c; 相对于 GPIO 基址寄存器的偏移量
init_GPDR0 EQU 0xfffbfe00 ; 寄存器 GPDR0 初值
LDR R1, = GPIO_BASE
LDR R0, = init_GPDR0
STR R0, [ R1, # GPDR0]
```
　　上述汇编代码段经编译后的结果为:
```c
LDR R1, [ PC, OFFSET_TO_GPIO_BASE]
LDR R0, [ PC, OFFSET_TO_init_GPDR0]
STR R0, [ R1, # 0x c]
...
GPIO_BASE DCD 0x40e00000
GPDR0 DCD 0x00c
init_GPDR0 DCD 0x fffbfe00
```
　　可见,LDR伪指令实际上使用基于PC的偏移量来对符号常量GPIO_BASE和init_GPDR0进行引用,因而是位置无关的。

　　由此可以得出如下结论:使用LDR伪指令将一个常量读取到非PC的其他通用寄存器中可实现位置无关的常量访问;但将一个地址值读取到PC中进行程序跳转时,跳转目标则是位置相关的。

## 2.2 程序设计规范2

　　其他被ROPI段中的代码引用的必须是绝对地址,或者是基于可读写位置无关(RWPI)段的静态基址寄存器的可写数据。

　　使用绝对地址只能引用被重定位到特定位置的代码段中的符号,通过在位置无关代码中引入绝对地址,可以让程序跳转到指定位置。例如,假设Bootloader的阶段1将其自身代码拷贝到链接时所指定的SDRAM地址空间后,当要跳转到阶段2的C程序入口时,可以使用指令`LDR　PC,=main`跳转到程序在SDRAM中的main函数入口地址开始执行。这是因为程序在编译链接时给main函数分派绝对地址,系统通过将main函数的绝对地
址直接赋给PC实现程序跳转。如果使用相对跳转指令`B main`,那么只会跳转到启动ROM内部的main函数入口。











　　
