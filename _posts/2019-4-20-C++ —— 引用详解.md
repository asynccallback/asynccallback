---
layout: post
title: "C++ 引用"
subtitle: C++ 引用
author: "404"
header-style: text
tags:
  - C++
---
# 1. 什么是引用

　　引用，是某一个变量或对象的别名，对引用的操作与对其所绑定的变量或对象的操作完全等价。引用的语法如下：
```
语法：类型 &引用名=目标变量名；
```

　　引用需要注意如下：
1. &在此不是求地址运算，而是起标识作用
2. 类型标识符是指目标变量的类型
3. 声明引用时，必须同时对其进行初始化
4. 引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名
5. 对引用求地址，就是对目标变量求地址。即我们常说引用名是目标变量名的一个别名。别名一词好像是说引用不占据任何内存空间。但是编译器在一般将其实现为const指针，即指向位置不可变的指针。即引用实际上与一般指针同样占用内存
6. 不能建立引用的数组。因为数组是一个由若干个元素所组成的集合，所以无法建立一个由引用组成的集合。但是可以建立数组的引用   

```cpp
 int& ref [3]= {2,3,5};//声明ref引用的数组错误

 const int (&ref)[3] ={2,3,5}; //gcc编译的时候加上选项 -std=c++0x
 ref[0] = 35; //错误
```   
　　为什么要加上const ,因为{2,3,5}此时是个字面值数组,是保存在代码段里,只读的属性,如果不加,编译错误,而且后面对ref[0]的赋值也不会成功

# 2. 引用的应用

## 2.1 引用作为函数的参数

```cpp
#include<iostream>
using namespace std;
void swap(int &a,int &b){//引用作为函数的参数
    int temp=a;
    a=b;
    b=temp;
}
int main(){
    int value1=10,value2=20;
    cout<<"----------------------交换前----------------------------"<<endl;
    cout<<"value1的值为："<<value1<<endl;
    cout<<"value2的值为："<<value2<<endl;
    swap(value1,value2);
    cout<<"----------------------交换后----------------------------"<<endl;
    cout<<"value1的值为："<<value1<<endl;
    cout<<"value2的值为："<<value2<<endl;
    return 0;
}
```

　　通常函数调用时，系统采用值传递的方式将实参变量的值传递给函数的形参变量。此时，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，也就是说形参变量只是实参变量的副本而已；并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象。  
　　而使用引用作为函数的形参时，由于此时形参只是要传递给函数的实参变量或对象的别名而非副本，故系统不会耗费时间来在内存中开辟空间来存储形参。**这里我理解的不开辟空间指的是：不会开辟实际变量大小的内存块，而会开辟指针形式的内存空间,这个下片文章分析**

## 2.2 常引用

　　常引用不允许通过该引用对其所绑定的变量或对象进行修改。
```cpp
#include<iostream>
using namespace std;
int main(){
    int a=10;
    const int &new_a=a;
    new_a=11;//错误！不允许通过常引用对其所绑定的变量或对象进行修改
    return 0;
}
```
　　下面情况编译器会报错
```cpp
#include<iostream>
#include<string>
using namespace std;
string func1(){
    string temp="This is func1";
    return temp;
}
void func2(string &str){
    cout<<str<<endl;
}
int main(){
    func2(func1());
    func2("Tomwenxing");
    return 0;
}
```
　　这是由于func1()和“Tomwenxing”都会在系统中产生一个临时对象（string对象）来存储它们，而在C++中所有的临时对象都是const类型的，而上面的程序试图将const对象赋值给非const对象，这必然会使程序报错。如果在函数func2的参数前添加const，则程序便可正常运行了。

## 2.3 引用作为函数的返回值
```cpp
#include<iostream>
using namespace std;
float temp;
float fn1(float r){
    temp=r*r*3.14;
    return temp;
}
float &fn2(float r){ //&说明返回的是temp的引用，换句话说就是返回temp本身
    temp=r*r*3.14;
    return temp;
}
int main(){
    float a=fn1(5.0); //case 1：返回值
    //float &b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type 'float&' from an rvalue of type 'float'
                           //（有些编译器可以成功编译该语句，但会给出一个warning）
    float c=fn2(5.0);//case 3：返回引用
    float &d=fn2(5.0);//case 4：用函数返回的引用作为新引用的初始化值
    cout<<a<<endl;//78.5
    //cout<<b<<endl;//78.5
    cout<<c<<endl;//78.5
    cout<<d<<endl;//78.5
    return 0;
}
```

　　**case1：用返回值方式调用函数**
![avatar](/img/in-post/Linux/201942001001.png)
　　返回全局变量temp的值时，C++会在内存中创建临时变量并将temp的值拷贝给该临时变量。当返回到主函数main后，赋值语句a=fn1(5.0)会把临时变量的值再拷贝给变量a。

　　**case2：用函数的返回值初始化引用的方式调用函数**
![avatar](/img/in-post/Linux/201942001002.png)
这种情况下，函数fn1()是以值方式返回到，返回时，首先拷贝temp的值给临时变量。返回到主函数后，用临时变量来初始化引用变量b，使得b成为该临时变量到的别名。由于临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束，也就是在语句float &b=fn1(5.0);之后） ，所以b面临无效的危险，很有可能以后的值是个无法确定的值。

 　　如果真的希望用函数的返回值来初始化一个引用，应当先创建一个变量，将函数的返回值赋给这个变量，然后再用该变量来初始化引用：
```cpp
int x=fn1(5.0);
int &b=x;
```
　　**case3：用返回引用的方式调用函数**
![avatar](/img/in-post/Linux/201942001003.png)
　　这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数，即主函数的赋值语句中的左值是直接从变量temp中拷贝而来（也就是说c只是变量temp的一个拷贝而非别名） ，这样就避免了临时变量的产生。尤其当变量temp是一个用户自定义的类的对象时，这样还避免了调用类中的拷贝构造函数在内存中创建临时对象的过程，提高了程序的时间和空间的使用效率。

　　**case4：用函数返回的引用作为新引用的初始化值的方式来调用函数**
![avatar](/img/in-post/Linux/201942001004.png)
　　这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数。在主函数中，一个引用声明d用该返回值初始化，也就是说此时d成为变量temp的别名。由于temp是全局变量，所以在d的有效期内temp始终保持有效，故这种做法是安全的。

## 2.4 用引用实现多态
　　在C++中，引用是除了指针外另一个可以产生多态效果的手段。也就是说一个基类的引用可以用来绑定其派生类的实例
```cpp
class Father;//基类（父类）
class Son：public Father{.....}//Son是Father的派生类
Son son;//son是类Son的一个实例
Father &ptr=son;//用派生类的对象初始化基类对象的使用
```

# 3. 总结

　　引用具有以下性质：  
1. 引用只能在定义时初始化一次，之后不能改变指向其它变量（从一而终）；指针变量的值可变。
2. 引用必须指向有效的变量(不能为NULL)，指针可以为空。
3. sizeof指针对象和引用对象的意义不一样。sizeof引用得到的是所指向的变量的大小，而sizeof指针是对象地址的大小。
4. 指针和引用自增(++)自减(--)意义不一样。
5. 相对而言，引用比指针更安全。

　　引用与指针的区别：  
1. 指针是一个实体，而引用仅是个别名；
2. 引用使用时无需解引用(*)，指针需要解引用；
3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
4. 引用没有 const，指针有 const；const修饰的指针不可变；
5. 引用不能为空，指针可以为空；
6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
7. 指针和引用的自增(++)运算意义不一样；
8. 从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。
