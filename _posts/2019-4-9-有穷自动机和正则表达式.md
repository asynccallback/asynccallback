---
layout: post
title: "有穷自动机和正则表达式"
subtitle: 有穷自动机和正则表达式
author: "404"
header-style: text
tags:
  - 编译原理
  - 有穷状态机
  - 正则表达式
  - Math

---

　　对于描述语言来说，正则表达式方法与有穷自动机方法是根本不同的，但这两种记号竟然表示完全相
同的语言集合，即所谓的“正则语言”。已经证明，确定型有穷自动机和两种非确定型有穷自动机（带$\xi$转移与不带$\xi$转移）接受相同的语言类。为了证明正则表达式定义了相同的类，就必须证明：
1. 用这些自动机之一定义的每个语言，也可以用正则表达式来定义。杜宇这个证明，可以假设某个DFA接受这个语言。
2. 用正则表达式定义的每个语言，也可以用这些自动机之一来定义。杜宇这部分证明，最容易的证明是有一个带$\xi$转移的NFA接受相同的语言。
![avatar](/img/in-post/Linux/201940901001.png)

# 1. 从DFA到正则表达式
　　构造正则表达式来定义任意DFA的语言出人意料地富有技巧性。大概地说，构造出描述标记DFA转移图中特定路径的串的集合的表达式。但是只允许这些路径经过一个有限的状态子集合。在这些表达式的归纳定理中，从描述不允许经过任何状态的路径（即这些路径是单个顶点或单条箭弧）的最简单表达式开始，然后归纳地构造让路径经过越来越大的状态集合的表达式。最后允许路径经过任何状态；即最终产生的表达式表示所有可能的路径。

　　**定理 如果对于某个DFA A，L = L(A),则存在一个正则表达式R，使得L = L(R)。**
　　**证明** 设对于某个整数n，A的状态是$\lbrace 1, 2, \ldots, n \rbrace$。无论A的状态实际是什么，对于某个有穷的n，都会有n个状态，通过为这些状态改名，可以以这种方式来引用这些状态，好像这些状态就是前n个正整数。第一项也是最困难的任务是构造一组正则表达式，来描述A的转移图中越来越大的路径集合。  
　　用$R_{ij}^{(k)}$作为正则表达式的名字，这些表达式的语言是下列串w的集合：使得w是A中从状态i到状态j的路径的标记，而且这条路径没有编号大于k的中间顶点。注意，路径的起点和终点都不是“中间的”，所以不限制i和（或）j要小于或等于k。  
　　下图提示了在$R_{ij}^{(k)}$所表示路径上的要求。其中，锤子方向表示状态，从底下的1到顶上的n；水平方向表示沿着路径前进。注意，在这个图中显示的i和j都比k大，但i和j之一或二者都可能是k或者更小。还要注意，这条路径两次结果顶点k，但除终点外，从不经过比k还高的状态。
![avatar](/img/in-post/Linux/201940901002.png)
　　为了构造表达式$R_{ij}^{(k)}$,使用下面的归纳定义，从$k = 0$开始，最终到达$k = n$。注意，当$k = n$时，在所表示的路径上根本没有限制，因为没有状态比n还大。  
　　**基础：** 基础是$k = 0$。由于所有状态都编号为1或更大，路径上的限制是：路径必定根本没有中间状态。只有两种路径满足这样的条件：
1. 从顶点（状态）i到顶点j的一条箭弧。
2. 只包含某个顶点i的长度为0的路径。

　　如果$i \neq j$,则只有情(1)是可能的。我们必须检查这个DFA A，并寻找这些输入符号a：是的在符号a上有从状态i到状态j的转移。
1. 如果没有这样的符号a，则$R_{ij}^{(0)} = \phi$。
2. 如果恰好有一个这样的符号a，则$R_{ij}^{(0)} = \bf{a}$
3. 如果有符号$a_1,a_2,\ldots,a_k$，都标记从状态i到状态j的箭弧，则$R_{ij}^{(0)} = \bf{a_1+a_2+\ldots+a_k}$  

　　但是，如果i = j，则合法路径长度为0的路径和所有从i到自身的环。长度为0的路径表示成正则表达式$\xi$，因为这个路径沿途没有符号。因此，把$\xi$加入上面(a)到(c)所涉及的各种表达式中。也就是说，在情形(1)下（没有符号a），表达式成为$\xi$;在情形(2)下（一个符号a），表达式成为$\xi+\bf{a}$；在情形(3)下（多个符号），表达式成为$\xi+\bf{a_1+a_2+\ldots+a_k}$。

　　**归纳：** 假设存在从i到j的路径不经过比k高的状态。有两种可能的情形需要考虑：
1. 这条路径根本不经过状态k。在这种情形下，路径的标记属于$R_{ij}^{(k-1)}$的语言。
2. 这条路径经过状态k至少一次。于是把路径分成几段，如下图所示。第一段不经过k而从状态i到状态k，最后一段不经过k而从状态k到j，所有总监路段都不经过k耳聪k到自身。注意，如果路径只经过状态k一次，则没有“中间”段，只有从i到k的路径和从k到j的路径。所有这种路径的标记的集合表示成正则表达式$R_{ik}^{(k-1)}{(R_{kk}^{(k-1)})}^\ast R_{kj}^{(k-1)}$。也就是说，第一个表达式表示第一次到达状态k的路径部分，第二个则表示从k到自身零次、一次或多次的部分，第三个表达式表示最后一次离开k并到达状态j的路径部分。
![avatar](/img/in-post/Linux/201940901003.png)
　　把上面两种路径的表达式组合起来，得到表达式

$$
R_{ij}^{(k)} = R_{ij}^{(k-1)} + R_{ik}^{(k-1)}{(R_{kk}^{(k-1)})}^{\ast}R_{kj}^{(k-1)}
$$

　　表示从状态i到状态j而不经过比k更高状态的所有路径的标记。如果按照上标递增的顺序来构造这些表达式，则由于每个$R_{ij}^{(k)}$只依赖于上标更小的表达式，所有的表达式都在需要时已经构造出来了。  
　　最终对于所有i和j，都得到$R_{ij}^{(n)}$。可以假设，状态1是初始状态，而接受状态可以是任意一组状态。自动机的语言的正则表达式，就是所有表达式$R_{ij}^{(n)}$之和(并)，使得状态j是接受状态。

# 2. 通过消除状态把DFA转化为正则表达式

　　把DFA转化为正则表达式的方法总是可行的。事实上，这个方法并不真正依赖于自动机是确定型的，同样可能应用到NFA甚至$\xi-NFA$上。但正则表达式构造代价太高。对于一个n状态自动机，不仅要构造大约$n^3$个表达式，而且如果不化简表达式，则在n个归纳步骤的每一步，表达式的长度平均增加到4倍。因此，这些表达式本身可能达到$4^n$个符号的长度级别。  
　　有一种类似的方法，在某些地方避免了重复工作。例如，在上个定理的构造中，对于每个i和j所有带上标k的表达式都利用同一个子表达式${(R_{kk}^{(k-1)})}^{\ast}$;因此写这个表达式的工作重复了$n^2$次。  
　　现在要学习的构造正则表达式的方法涉及消除状态。当消除状态s时，自动机中经过s的所有路径都不存在了。如果不打算改变自动机的语言，就必须在从q直接到p的箭弧上包含经过s而从状态q到状态p的路径的标记。由于这种箭弧的标记现在可能涉及串，而不是单个符号，而且甚至可能有无穷多个这样的串，所以不能简单地列举这些个串作为标记。幸运的是，有一种简单且有穷的方法来表示所有这样的串：使用正则表达式。  
　　因此，结果是考虑用正则表达式作为标记的自动机。这种自动机的语言是，把所有从初始状态到某个接受状态的路径沿途的正则表达式连接起来形成的语言的并。注意，这条规则与目前考虑过的任何变种自动机语言的定义都是一致的。每个符号a或者$\xi$（若允许）都可看作正则表达式，其语言就是单个串{a}或$\lbrace \xi \rbrace$。把这个事实作为下一步描述的状态消除过程的基础。  
　　下图显示一个将被消除的一般状态s。假设s所属的自动机以$q_1,q_2,\ldots,q_k$作为s的前驱状态，以$p_1,p_2,\ldots,p_m$作为s的后继状态。有可能某些q和p是相同的，但是假设：即使有从s到其自身的环，s也不出现在这些q或p中。在每个从一个q到s的箭弧上，还显示了一个正则表达式；从$Q_i$出发的箭弧用表达式$Q_i$标记。同样，对所有的i，显示了标记从s到$p_i$的箭弧的正则表达式$P_i$。在s上显示了带标记S的环。最后，对所有的i和j，在从$Q_i$到$p_i$的箭弧上有正则表达式$R_{ij}$。注意，这些箭弧中有一些可能在这个自动机中并不存在，在这种情况下，就让这个箭弧上的表达式为$\phi$。
![avatar](/img/in-post/Linux/201940901004.png)
　　下图显示当消除状态s时发生什么。删除了所有涉及状态s的箭弧。作为补偿，对于s的每个前驱$q_i$以及每个后继$p_j$，都引入一个正则表达式，来表示所有从$q_i$出发到s、可能绕s循环零次或多次、最后到达$p_j$的路径。这些路径的表达式是$Q_iS^\ast P_j$。把这个表达式（用并运算）加到从$q_i$到$p_j$的箭弧上。如果没有箭弧$q_i \rightarrow p_j$,就先引入一个这种箭弧，上面带有正则表达式$\phi$。
![avatar](/img/in-post/Linux/201940901005.png)

　　从有穷自动机构造正则表达式的策略如下：
1. 对于每个接受状态q，应用上面的消除过程，产生一个等价的自动机，箭弧上带有正则表达式标记。消除除了q和初始状态$q_0$以外的所有其余状态。
2. 如果$q \neq q_0$,则剩下一个两状态自动机，如下图所示。可以用多种方式来描述所接受的串的正则表达式。一种方式是$ {(R + SU^\ast T)}^{\ast}SU^{\ast} $。解释如下，沿着标记属于L(R)或者$L(SU^{\ast}T)$的一些列路径，从初始状态到自身任意多次。表达式$SU^\ast T$表示这样的路径：经过属于L(S)的路径到达接受状态，可能用标记属于L(U)的一系列路径多次回到接受状态，然后用标记属于L(T)的路径返回初始状态。然后必须沿着标记属于L(S)的路径，到达接受状态而永不返回初始状态。一旦处在接受状态，沿着标记属于L(U)的路径，就可以随意地返回接受状态任意多次。  
![avatar](/img/in-post/Linux/201940901006.png)  
3. 如果初始状态也是接受状态，就必须对原来的自动机也执行消除，去掉除初始状态以外的所有其余状态。这样做了以后，剩下一个单状态自动机，如下图，表示正则表达式$R\ast$。
![avatar](/img/in-post/Linux/201940901007.png)  
4. 所求的正则表达式是对每个接受状态用规则(2)和(3)从化简的自动机得出的所有表达式之和（并）。
