---
layout: post
title: "Uboot-Nandflash进阶＜二＞"
subtitle: Uboot-Nandflash进阶分析
author: "404"
header-style: text
tags:
  - Linux
  - Arm
  - Uboot
  - NANDflash
---
>本篇文章转载自[【详解】如何编写Linux下Nand Flash驱动](https://www.crifan.com/files/doc/docbook/linux_nand_driver/release/html/linux_nand_driver.html),写的挺好



# 2. 硬件特性

## 2.9 Nand Flash引脚(Pin)的说明
![avatar](/img/in-post/Linux/201933101006.png)
　　上图是常见的Nand Flash所拥有的引脚（Pin）所对应的功能，简单翻译如下：
![avatar](/img/in-post/Linux/201933101007.png)
　　在数据手册中，你常会看到，对于一个引脚定义，有些字母上面带一横杠的，那是说明此引脚/信号是低电平有效，比如你上面看到的RE头上有个横线，就是说明，此RE是低电平有效，此外，为了书写方便，在字母后面加“＃”，也是表示低电平有效，比如我上面写的CE＃；如果字母头上啥都没有，就是默认的高电平有效，比如上面的CLE，就是高电平有效。

### 2.9.1 为何需要ALE和CLE
　　硬件上，有了电源的Vcc和接地的Vss等引脚，很好理解，但是为何还要有ALE和CLE这样的引脚，为何设计这么多的命令,把整个系统搞这么复杂，关于这点，最后终于想明白了：   
　　设计命令锁存使能(Command Latch Enable, CLE) 和 地址锁存使能(Address Latch Enable，ALE)，那是因为，Nand Flash就8个I/O，而且是复用的，也就是，可以传数据，也可以传地址，也可以传命令，为了区分你当前传入的到底是啥，所以，先要用发一个CLE（或ALE）命令，告诉Nand Flash的控制器一声，我下面要传的是命令（或地址），这样，里面才能根据传入的内容，进行对应的动作。否则,Nand Flash内部,怎么知道你传入的是数据,还是地址,还是命令,也就无法实现正确的操作了。

### 2.9.2 Nand Flash只有8个I/O引脚的好处
　　在Nand Flash的硬件设计中，你会发现很多个引脚。关于硬件上为何设计这样的引脚，而不是直接像其他存储设备，比如普通的RAM，直接是一对数据线引出来，多么方便和好理解啊。
　　关于这样设计的好处：   
1. 减少外围连线
相对于并口(Parellel)的Nor Flash的48或52个引脚来说，的确是大大减小了引脚数目，这样封装后的芯片体积，就小很多。现在芯片在向体积更小，功能更强，功耗更低发展，减小芯片体积，就是很大的优势。同时，减少芯片接口，也意味着使用此芯片的相关的外围电路会更简化，避免了繁琐的硬件连线。
2. 提高系统的可扩展性   
因为没有像其他设备一样用物理大小对应的完全数目的addr引脚，在芯片内部换了芯片的大小等的改动，对于用全部的地址addr的引脚，那么就会引起这些引脚数目的增加，比如容量扩大一倍，地址空间/寻址空间扩大一倍，所以，地址线数目/addr引脚数目，就要多加一个，而对于统一用8个I/O的引脚的Nand Flash，由于对外提供的都是统一的8个引脚，内部的芯片大小的变化或者其他的变化，对于外部使用者(比如编写Nand Flash驱动的人)来说，不需要关心，只是保证新的芯片，还是遵循同样的接口，同样的时序，同样的命令，就可以了。这样就提高了系统的扩展性。

　　说白了，对于旧的Nand Flash所实现的驱动，这些软件工作，在换新的硬件的Nand Flash的情况下，仍然可以工作，或者是通过极少的修改，就同样可以工作，使得软硬件兼容性大大提高。

## 2.10 Nand Flash的一些典型(typical)的特性
1. 页擦除时间是200us，有些慢的有800us
2. 块擦除时间是1.5ms
3. 页数据读取到数据寄存器的时间一般是20us
4. 串行访问（Serial access）读取一个数据的时间是25ns，而一些旧的Nand Flash是30ns，甚至是50ns
5. 输入输出端口是地址和数据以及命令一起multiplex复用的
6. Nand Flash的编程/擦除的寿命：即，最多允许的擦除的次数   
以前老的Nand Flash，编程/擦除时间比较短，比如K9G8G08U0M，才5K次，而后来的多数也只有10K=1万次，而现在很多新的Nand Flash，技术提高了，比如，Micron的MT29F1GxxABB，Numonyx的 NAND04G-B2D/NAND08G-BxC，都可以达到100K，也就是10万次的7编程/擦除，达到和接近于之前常见的Nor Flash，几乎是同样的使用寿命了。
7. 封装形式   
48引脚的TSOP1封装 或 52引脚的ULGA封装

## 2.11 Nand Flash控制器与Nand Flash芯片
　　关于Nand Flash的控制器Controller和Nand Flash芯片chip之间的关系，觉得有必要解释一下：

　　首先，我们要知道的是，我们写驱动，是写Nand Flash 控制器的驱动，而不是Nand Flash 芯片的驱动，因为独立的Nand Flash芯片，一般来说，是很少直接拿来用的，多数都是硬件上有对应的硬件的Nand Flash的控制器，去操作和控制Nand Flash，包括提供时钟信号，提供硬件ECC校验等等功能，我们所写的驱动软件，是去操作Nand Flash的控制器

　　然后由控制器去操作Nand Flash芯片，实现我们所要的功能。

## 2.12. Nand Flash中的特殊硬件结构
　　由于Nand Flash相对其他常见设备来说，比较特殊，所以，特殊的设备，就有特殊的设计，就对应某些特殊的硬件特性，就有必要解释解释：

　　页寄存器（Page Register）：

　　由于Nand Flash读取和编程操作来说，一般最小单位是页，所以Nand Flash在硬件设计时候，就考虑到这一特性，对于每一片（Plane），都有一个对应的区域专门用于存放，将要写入到物理存储单元中去的或者刚从存储单元中读取出来的，一页的数据，这个数据缓存区，本质上就是一个缓存buffer，但是只是此处datasheet里面把其叫做页寄存器page register而已，实际将其理解为页缓存，更贴切原意。

　　而正是因为有些人不了解此内部结构，才容易产生之前遇到的某人的误解，以为内存里面的数据，通过Nand Flash的FIFO，写入到Nand Flash里面去，就以为立刻实现了实际数据写入到物理存储单元中了，而实际上只是写到了这个页缓存中，只有当你再发送了对应的编程第二阶段的确认命令，即0x10，之后，实际的编程动作才开始，才开始把页缓存中的数据，一点点写到物理存储单元中去。

　　所以，简单总结一下就是，对于数据的流向，实际是经过了如下步骤：
![avatar](/img/in-post/Linux/201940101001.png)

## 2.13 Nand Flash中的坏块(Bad Block)
　　Nand Flash中，一个块中含有1个或多个位是坏的，就称为其为坏块Bad Block。

　　坏块的稳定性是无法保证的，也就是说，不能保证你写入的数据是对的，或者写入对了，读出来也不一定对的。与此对应的正常的块，肯定是写入读出都是正常的。

### 2.13.1 坏块的分类
　　坏块有两种：
1. 出厂时就有存在的坏块   
一种是出厂的时候，也就是，你买到的新的，还没用过的Nand Flash，就可以包含了坏块。此类出厂时就有的坏块，被称作factory (masked) bad block或initial bad/invalid block，在出厂之前，就会做对应的标记，标为坏块。
2. 使用过程中产生的坏块   
第二类叫做在使用过程中产生的，由于使用过程时间长了，在擦块除的时候，出错了，说明此块坏了，也要在程序运行过程中，发现，并且标记成坏块的。具体标记的位置，和上面一样。这类块叫做worn-out bad block。即用坏了的块。

### 2.13.2 坏块的标记
　　具体标记的地方是，对于现在常见的页大小为2K的Nand Flash，是块中第一个页的oob起始位置（关于什么是页和oob，下面会有详细解释）的第1个字节（旧的小页面，pagesize是512B甚至256B的Nand Flash，坏块标记是第6个字节），如果不是0xFF，就说明是坏块。相对应的是，所有正常的块，好的块，里面所有数据都是0xFF的。

　　不过，对于现在新出的有些Nand Flash，很多标记方式，有些变化，有的变成该坏块的第一个页或者第二个页，也有的是，倒数最后一个或倒数第二个页，用于标记坏块的。

　　具体的信息，请参考对应的Nand Flash的数据手册，其中会有说明。

　　对于坏块的标记，本质上，也只是对应的flash上的某些字节的数据是非0xFF而已，所以，只要是数据，就是可以读取和写入的。也就意味着，可以写入其他值，也就把这个坏块标记信息破坏了。对于出厂时的坏块，一般是不建议将标记好的信息擦除掉的。

　　uboot中有个命令是
```c
nand scrub
```
　　就可以将块中所有的内容都擦除了，包括坏块标记，不论是出厂时的，还是后来使用过程中出现而新标记的。一般来说，不建议用这个。

　　不过，在实际的驱动编程开发过程中，为了方便起见，我倒是经常用，其实也没啥大碍，呵呵。不过呢，其实最好的做法是，用
```c
nand erase
```
　　只擦除好的块，对于已经标记坏块的块，不要轻易擦除掉，否则就很难区分哪些是出厂时就坏的，哪些是后来使用过程中用坏的了。

### 2.13.3 坏块的管理
　　对于坏块的管理，在Linux系统中，叫做坏块管理（BBM，Bad Block Management），对应的会有一个表去记录好块，坏块的信息，以及坏块是出厂就有的，还是后来使用产生的，这个表叫做坏块表（BBT，Bad Block Table）。在Linux 内核MTD架构下的Nand Flash驱动，和Uboot中Nand Flash驱动中，在加载完驱动之后，如果你没有加入参数主动要求跳过坏块扫描的话，那么都会去主动扫描坏块，建立必要的BBT的，以备后面坏块管理所使用。

### 2.13.4 坏块的比例
　　而关于好块和坏块，Nand Flash在出厂的时候，会做出保证：   
1. 关于好的，可以使用的块的数目达到一定的数目，比如三星的K9G8G08U0M，整个flash一共有4096个块，出厂的时候，保证好的块至少大于3996个，也就是意思是，你新买到这个型号的Nand Flash，最坏的可能， 有3096－3996＝100个坏块。不过，事实上，现在出厂时的坏块，比较少，绝大多数，都是使用时间长了，在使用过程中出现的。
2. 保证第一个块是好的，并且一般相对来说比较耐用。做此保证的主要原因是，很多Nand Flash坏块管理方法中，就是将第一个块，用来存储上面提到的BBT，否则，都是出错几率一样的块，那么也就不太好管理了，连放BBT的地方，都不好找了。
一般来说，不同型号的Nand Flash的数据手册中，也会提到，自己的这个Nand Flash，最多允许多少个坏块。就比如上面提到的，三星的K9G8G08U0M，最多有100个坏块。

## 2.14. Nand Flash中页的访问顺序
　　在一个块内，对每一个页进行编程的话，必须是顺序的，而不能是随机的。比如，一个块中有128个页，那么你只能先对page0编程，再对page1编程，。。。。，而不能随机的，比如先对page3，再page1，page2，page0，page4，。。。

　　关于此处对于只能顺序给页编程的说法，只是翻译自datasheet，但是实际情况却发现是，程序中没有按照此逻辑处理，可以任意对某Block内的Page去做Program的动作，而不必是顺序的。但是datasheet为何如此解释，原因未知，有待知情者给解释一下。

## 2.15. 常见的Nand Flash的操作
　　要实现对Nand Flash的操作，比如读取一页的数据，写入一页的数据等，都要发送对应的命令，而且要符合硬件的规定，如图：
![avatar](/img/in-post/Linux/201940101002.png)
　　从上图可以看到，如果要实现读一个页的数据，就要发送Read的命令，而且是分两个周期（Cycle），即分两次发送对应的命令，第一次是0x00h,第二次是0x30h，而两次命令中间，需要发送对应的你所要读取的页的地址，关于此部分详细内容，留待后表。

　　对应地，其他常见的一些操作，比如写一个页的数据(Page Program)，就是先发送0x80h,然后发生要写入的地址，再发送0x10h。
　　关于一些常见的操作，比如读一个页的Read操作和写一个页的Page Program，下面开始更深入的介绍。

### 2.15.1 页编程（Page Program）注意事项
　　Nand flash的写操作叫做编程Program，编程，一般情况下，是以页为单位的。

　　有的Nand Flash，比如K9K8G08U0A，支持部分页编程（Partial Page Program），但是有一些限制：在同一个页内的，连续的部分页的编程，不能超过4次。

　　一般情况下，都是以页为单位进行编程操作的，很少使用到部分页编程。

　　关于这个部分页编程，本来是一个页的写操作，却用两个命令或更多的命令去实现，看起来是操作多余，效率不高，但是实际上，有其特殊考虑：

　　至少对于块擦除来说，开始的命令0x60是擦除设置命令(erase setup comman)，然后传入要擦除的块地址，然后再传入擦除确认命令（erase confirm command）0xD0，以开始擦除的操作。

　　这种完成单个操作要分两步发送命令的设计，即先开始设置，再最后确认的命令方式，是为了避免由于外部由于无意的/未预料而产生的噪音，比如，由于某种噪音，而产生了0x60命令，此时，即使被Nand Flash误认为是擦除操作，但是没有之后的确认操作0xD0，Nand Flash就不会去擦除数据，这样使得数据更安全，不会由于噪音而误操作。

### 2.15.2. 读（Read）操作过程详解
　　下面以最简单的read操作为例，解释如何理解时序图，以及将时序图中的要求，转化为代码。

　　解释时序图之前，让我们先要搞清楚，我们要做的事情：

　　从Nand Flash的某个页Page里面，读取我们要的数据。

　　要实现此功能，会涉及到几部分的知识，即使我们不太懂Nand Flash的细节，但是通过前面的基本知识的介绍，那么以我们的常识，至少很容易想到的就是，需要用到哪些命令，怎么发这些命令，怎么计算所需要的地址，怎么读取我们要的数据等等。

　　下面就一步步的解释，需要做什么，以及如何去做：

#### 2.15.2.1 需要使用何种命令
　　首先，是要了解，对于读取数据，要用什么命令：

　　根据前面关于Nand Flash的命令集合介绍，我们知道，要读取数据，要用到Read命令，该命令需要2个周期，第一个周期发0x00，第二个周期发0x30。

#### 2.15.2.2 发送命令前的准备工作以及时序图各个信号的具体含义
　　知道了用何命令后，再去了解如何发送这些命令。
```
在开始解释前，关于”使能”这个词要罗嗦一下，以防有些读者和我以前一样，在听这类词语的时候，
属于初次接触，或者接触不多的，就很容易被搞得一头雾水的
（虽然该词汇对于某些专业人士说是属于最基本的词汇了，囧）。

使能（Enable），是指使其（某个信号）有效，使其生效的意思，“使其”“能够”怎么怎么样。。。。
比如，上面图中的CLE线号，是高电平有效，如果此时将其设为高电平，
我们就叫做，将CLE使能，也就是使其生效的意思。
```
![avatar](/img/in-post/Linux/201940101003.png)

　　我们来一起看看，我在图6中的特意标注的①边上的黄色竖线。

　　黄色竖线所处的时刻，是在发送读操作的第一个周期的命令0x00之前的那一刻。

　　让我们看看，在那一刻，其所穿过好几行都对应什么值，以及进一步理解，为何要那个值。
1. 黄色竖线穿过的第一行，是CLE。还记得前面介绍命令所存使能（CLE）那个引脚吧？CLE，将CLE置1，就说明你将要通过I/O复用端口发送进入Nand Flash的，是命令，而不是地址或者其他类型的数据。只有这样将CLE置1，使其有效，才能去通知了内部硬件逻辑，你接下来将收到的是命令，内部硬件逻辑，才会将受到的命令，放到命令寄存器中，才能实现后面正确的操作，否则，不去将CLE置1使其有效，硬件会无所适从，不知道你传入的到底是数据还是命令了。
2. 而第二行，是CE#，那一刻的值是0。这个道理很简单，你既然要向Nand Flash发命令，那么先要选中它，所以，要保证CE#为低电平，使其有效，也就是片选有效。
3. 第三行是WE#，意思是写使能。因为接下来是往Nand Flash里面写命令，所以，要使得WE#有效，所以设为低电平。
4. 第四行，是ALE是低电平，而ALE是高电平有效，此时意思就是使其无效。而对应地，前面介绍的，使CLE有效，因为将要数据的是命令（此时是发送图示所示的读命令第二周期的0x30），而不是地址。如果在其他某些场合，比如接下来的要输入地址的时候，就要使其有效，而使CLE无效了。
5. 第五行，RE#，此时是高电平，无效。可以看到，知道后面低6阶段，才变成低电平，才有效，因为那时候，要发生读取命令，去读取数据。
6. 第六行，就是我们重点要介绍的，复用的输入输出I/O端口了，此刻，还没有输入数据，接下来，在不同的阶段，会输入或输出不同的数据/地址。
7. 第七行，R/B#,高电平，表示R（Ready）/就绪，因为到了后面的第5阶段，硬件内部，在第四阶段，接受了外界的读取命令后，把该页的数据一点点送到页寄存器中，这段时间，属于系统在忙着干活，属于忙的阶段，所以，R/B#才变成低，表示Busy忙的状态的。

#### 2.15.2.3. 如何计算出我们要传入的行地址和列地址
　　在介绍具体读取数据的详细流程之前，还要做一件事，那就是，先要搞懂我们要访问的地址，以及这些地址，如何分解后，一点点传入进去，使得硬件能识别才行。

　　此处还是以K9K8G08U0A为例，此Nand Flash，一共有8192个块，每个块内有64页，每个页是2K+64 Bytes。

　　假设，我们要访问其中的第7000个块中的第64页中的1208字节处的地址，此时，我们就要先把具体的地址算出来：   
物理地址
=块大小×块号 ＋ 页大小×页号 ＋ 页内地址   
=128K×7000 ＋ 2K×64 ＋ 1208   
=0x36B204B8

　　接下来，我们就看看，怎么才能把这个实际的物理地址，转化为Nand Flash所要求的格式。

　　在解释地址组成之前，先要来看看其datasheet中关于地址周期的介绍：
![avatar](/img/in-post/Linux/201940101004.png)
　　结合图 1.7 “Nand Flash数据读取操作的时序图”中的2，3阶段，我们可以看出，此Nand Flash地址周期共有5个，2个列(Column)周期，3个行（Row）周期。   
1. 对应地，列地址A0~A10，就是页内地址，地址范围是从0到2047。
细心的读者可能注意到了，为何此处多出来个A11呢？
这样从A0到A11，一共就是12位，可以表示的范围就是0~212，即0~4096了。
实际上，由于我们访问页内地址，可能会访问到oob的位置，即2048-2111这64个字节的范围内，所以，此处实际上只用到了2048～2111，用于表示页内的oob区域，其大小是64字节。
2. 对应地，A12～A30，称作页号，页的号码，可以定位到具体是哪一个页。
A18～A30，表示对应的块号，即属于哪个块。

　　简单解释完了地址组成，那么就很容易分析上面例子中的地址了。

　　注意，下面这样的方法，是错误的：

`0x36B204B8 = 11 0110 1011 0010 0000 0100 1011 1000`，分别分配到5个地址周期就是：

1st周期 |	A7 ～ A0	| 1011 1000 = 0xB8
2nd周期	|	A11～ A8	|	0100 = 0x04
3rd周期	|	A19～A12	|	0010 0000 = 0x20
4th周期	|	A27～A20	|	0110 1011 = 0x6B
5th周期	|	A30～A28	|	11 = 0x03

　　而至于上述计算方法为何是错误的，那是因为上面计算过程中，把第11位的值，本来是属于页号的位A11，给算成页内地址里面的值了。

　　应该是这样计算，才是对的：

`0x36B204B8 = 11 0110 1011 0010 0000 0100 1011 1000`

1st周期	|	A7 ～ A0	|	1011 1000 = 0xB8
2nd周期	|	A10～ A8	|	100 = 0x04
3rd周期	|	A19～A12	|	010 0000 0 = 0x40
4th周期	|	A27～A20	|	110 1011 0 = 0xD6
5th周期	|	A30～A28	|	11 0 = 0x06

　　那有人会问了，上面表11中，不是明明写的A0到A30，其中包括A11，不是正好对应着此处地址中的bit0到bit30吗？

　　其实，我开始也是犯了同样的错误，误以为我们要传入的地址的每一位，就是对应着表11中的A0到A30呢，实际上，表11中的A11，是比较特殊的，只有当我们访问页内地址处于oob的位置，即属于2048~2111的时候，A11才会其效果，才会用A0-A11用来表示对应的某个属于2048~2111的某个值，属于oob的某个位置。

　　而我们此处的页内地址为2108，还没有超过2047呢，所以A11肯定是0。

　　这么解释，显得很绕，很难看懂。换种方式来解释，就容易听懂了。说白了，我们就是要访问第7000个块中的第64页中的1208字节处，对应着：   
页内地址   
=1208   
=0x4B8

页号   
=块数×页数/块 + 块内的页号   
= 7000×（128K/2K） + 64   
= 7000×64 + 64   
= 448064   
=0x6D640

　　也就是，我们要访问0x6D640页内的0x4B8地址，这样很好理解吧。

　　然后对应的：页内地址=0x4B8

　　分成两个对应的列地址，就变成0x4B8 ：列地址1=0xB8，列地址2=0x04

　　页号=0x6D640，分成三个行号就是：
0x6D640：   
行号1=0x40，   
行号2=0xD6，   
行号3=0x06

再回头看看上面的计算方法，最开始计算出来的：   
列地址1=0xB8   
列地址2=0x04   
行号1=0x20   
行号2=0x6B   
行号3=0x03   
是错误的。   

而第二次计算正确的：
列地址1=0xB8   
列地址2=0x04   
行号1=0x40   
行号2=0xD6   
行号3=0x06      
才是对的，也和我们此处自己手动计算，是一致的。

　　第一次之所以计算错，就是错误的把行地址的最低一位A11，放到列地址中的最高位了。

　　至此，才算把如何手动计算行地址和列地址，解释明白和正确了。

#### 2.15.2.4 读操作过程的解释
　　准备工作终于完了，下面就可以开始解释说明，对于读操作的，上面图中标出来的，1-6个阶段，具体是什么含义。

　　操作准备阶段：此处是读（Read）操作，所以，先发一个图5中读命令的第一个阶段的0x00,表示，让硬件先准备一下，接下来的操作是读。

　　发送两个周期的列地址。也就是页内地址，表示，我要从一个页的什么位置开始读取数据。

　　接下来再传入三个行地址。对应的也就是页号。

　　然后再发一个读操作的第二个周期的命令0x30。接下来，就是硬件内部自己的事情了。

　　Nand Flash内部硬件逻辑，负责去按照你的要求，根据传入的地址，找到哪个块中的哪个页，然后把整个这一页的数据，都一点点搬运到页缓存中去。而在此期间，你所能做的事，也就只需要去读取状态寄存器，看看对应的位的值，也就是R/B#那一位，是1还是0，0的话，就表示，系统是busy，仍在”忙“（着读取数据），如果是1，就说系统活干完了，忙清了，已经把整个页的数据都搬运到页缓存里去了，你可以接下来读取你要的数据了。

　　对于这里。估计有人会问了，这一个页一共2048+64字节，如果我传入的页内地址，就像上面给的1208一类的值，只是想读取1028到2011这部分数据，而不是页开始的0地址整个页的数据，那么内部硬件却读取整个页的数据出来，岂不是很浪费吗？答案是，的确很浪费，效率看起来不高，但是实际就是这么做的，而且本身读取整个页的数据，相对时间并不长，而且读出来之后，内部数据指针会定位到你刚才所制定的1208的那个位置。

　　接下来，就是你“窃取“系统忙了半天之后的劳动成果的时候了，呵呵。通过先去Nand Flash的控制器中的数据寄存器中写入你要读取多少个字节(byte)/字(word)，然后就可以去Nand Flash的控制器的FIFO中，一点点读取你要的数据了。

　　至此，整个Nand Flash的读操作就完成了。

　　对于其他操作，可以根据我上面的分析，一点点自己去看datasheet，根据里面的时序图去分析具体的操作过程，然后对照代码，会更加清楚具体是如何实现的。
