---
layout: post
title: "arm-存储体系＜三＞"
subtitle: arm中MMU介绍
author: "404"
header-style: text
tags:
  - Linux
  - arm
  - Memory
  - MMU
---

>本篇文章来源于《ARM体系结构与编程》，写得挺好

#### 存储器管理单元MMU概述

在ARM系统中，存储器管理单元MMU中要完成以下工作：
- 虚拟存储空间到物理存储空间的映射。在ARM中采用了页式虚拟存储管理。它把虚拟地址空间分成一个个固定大小的快，每一块称为一页，把物理内存的地址空间也分成同样大小的页。页的大小可以分为粗粒度和细粒度两种。MMU 就要实现从虚拟地址到物理地址的转换。
- 存储器访问权限的控制
- 设置虚拟存储空间的缓冲的特性

页表(Translate Table)是实现上述这些功能的重要手段，它是一个位于内存中的表。表的每一行对应于虚拟存储空间的一个页，该行包含了该虚拟内存页（称为虚页）对应的物理内存页（称为实页）的地址、该页的访问权限和该页的缓冲特性等。这里将页表中的一行称为一个地址变换条目(Entry)。

贞表存放在内存中，系统通常用一个寄存器来保存页表的基地址。在ARM中，系统控制协处理器 CP15 的寄存器C2用来保存页表的基地址。

从虚拟地址到物理地址的变换过程其实就是查询页表的过程，由于页表存放在内存中，这个查询过程通常代价很大。而程序在执行过程中具有局部性，因此，对页表中各存储器的访问并不是完全随机的。也就是说，在一段时间内，对页表的访问只是局限在少数几个单元中。根据这一特点，采用一个容量更小（通常为8~16个字）、访问速度和CPU中通用寄存器相当的存储器件来存放当前访问需要的地址变换条目。这个小容量的页表称为快表。快表在英文资料中被称为TLB(Translation Look aside Buffer)。

当CPU需要访问内存时，先在TLB中查找需要的地址变换条目。如果该条目不存在，CPU 从位于内存中的页表中查询，并把相应的结果添加到TLB中。 这样，当CPU下一次又需要该地址变换条目时，就可以从TLB中直接得到了， 从而使地址变换的速度大大加快。

当内存中的页表内容改变，或者通过修改系统控制协处理器CP15的寄存器 C2使用新的页表时，TLB中的内容需要全部清除。MMU提供了相关的硬件支持这种操作。系统控制协处理器CP15的寄存器CS用来控制清除TLB内容的相关操作。

MMU可以将某些地址变换条目锁定(Locked Down)在TLB中，从而使得进行与该地址变换条目相关的地址变换速度保持很快。在MMU中，寄存器C10用于控制TLB内容的锁定。

MMU可以将整个存储空间分为最多16个域(Domain)。每个域对应一定的内存区域，该区域具有相同的访问控制属性。MMU中，寄存器C3用于控制与域相关的属性的配置。

当存储访问失效时，MMU提供了相应的机制用于处理这种情况。在MMU中， 寄存器C5和寄存器C6用于支待这些机制。

与MMU操作相关的寄存器如下：
![avatar](/img/in-post/Linux/201931103001.png)
![avatar](/img/in-post/Linux/201931103002.png)

### 禁止/使能MMU

CP15的寄存器C1的位[0]用于控制禁止/使能MMU。当CP15的寄存器C1的位[0]设置成0时，禁止MMU; 当CP15的寄存器C1的位[0]设置成1时，使能MMU。下面的指令使能MMU:
```
MRC P15,0,R0,C1,0, 0
ORR R0,#01
MCR P15,0,R0,C1,0,0
```

1. 使能MMU时存储访问过程

   当ARM处理器请求存储访问时，首先在TLB中查找虚拟地址。如果系统中数据TLB和指令TLB是分开的，在取指令时，从指令TLB查找相应的虚拟地址， 对于其他的内存访问操作，从数据TLB中查找相应的虚拟地址。

   如果该虚拟地址对应的地址变换条目不在TLB中，CPU从位于内存中的页表中查询对应于该虚拟地址的地址变换条目，并把相应的结果添加到TLB中。 如果TLB已经满了，还需要根据一定的淘汰算法进行替换。这样，当CPU下次又需要该地址变换条目时，可以从TLB中直接得到，从而使地址变换的速度大大增加。

   当得到了需要的地址变换条目后，将进行以下的操作：
   1. 得到该虚拟地址对应的物理地址
   2. 根据条目中的C(Cacheable)控制位和B(Bufferable)控制位决定是否缓存该内存访问的结果。
   3. 据存取权限控制位和域访问控制位确定该内存访问是否被允许如果该内存访问不被允许，CP15向ARM处理器报告存储访问中止。
   4. 对于不允许缓存(Uncached)的存储访问，使用步骤(1)中得到的物理地址访问内存。对于允许缓存(Cached)的存储访问，如果Cache命中，则忽略物理地址；如果Cache没有命中，则使用步骤(1)中得到的物理地址访问内存，并把该块数据读取到Cache中。

   下图是允许缓存(Cached)的MMU存储访问示意图：
   ![avatar](/img/in-post/Linux/201931103003.png)

2. 禁止MMU时存储访问过程
当禁止MMU时，存储访问规则如下所示：
- 当禁止MMU时，是否支持Cache和Write Buffer由各个具体芯片的设计确定。 如果芯片规定当禁止MMU时禁止 Cache和Write Buffer, 则存储访问将不考虑 C、B控制位。 如果芯片规定当禁止MMU时可以使能Cache和Write Buffer, 则数据访问时，C=0, B=0；指令读取时，如果使用分开的TLB, 则C=l, 如果使统一的TLB，则C=0
- 存储访问不进行权限控制，MMU也不会产生存储访问中止信号
- 所有的物理地址和虚拟地址相等，即使用普通存储模式

3. 禁止/使能MMU时应注意的问题
禁止/使能MMU时，应注意下面几点：
- 在使能MMU之前，要在内存中建立页号表，同时CP15中的各相关寄存器必须完成初始化
- 如果使用的不是普通存储模式（物理地址和对应的虚拟地址相等），在禁止/使能 MMU时，虚拟地址和物理地址的对应关系会发生改变，这时应该清除Cache中的当前地址变换条目
- 如果完成禁止/使能MMU的代码的物理地址和虚拟地址不相同， 则禁止/使能MMU时将造成很大的麻烦， 因此强烈建议完成禁止/使能MMU的代码的物理地址和虚拟地址最好相同。
