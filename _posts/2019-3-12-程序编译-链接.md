---
layout: post
title: "程序编译-链接"
subtitle: 程序编译过程中的链接(ld)
author: "404"
header-style: text
tags:
  - Linux
  - arm
  - 程序编译
  - ld
---

>本篇文章是原创，转载请注明

```c
#include <stdio.h>

int main()
{
  printf("hello, world!")
}
```

在我们最先接触C语言写程序的时候一般都是以这个程序开头，这个程序我们是能读懂，但是计算机如何理解？计算机懂的只有0、1，他要理解这些的话，需要我们进行一些处理。我们会把他编译成一个可执行的目标程序:
```
gcc -o hello hello.c
```
在这里，我们依靠gcc编译驱动程序来读取源文件，并将其翻译成一个可执行的目标程序文件。这个翻译的过程通过4个阶段来完成。执行这是个阶段的程序(预处理器、编译器、汇编器和链接器)一起构成了编译系统。
![avatar](/img/in-post/Linux/201931201001.png)

- 预处理阶段。预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。比如hello.c中第一行的的`#include<stdio.h>`指令告诉预处理器读取系统头文件`stdio.h`的内容，并把它直接插入到程序文本中去。结果就得到了另外一个C程序，通常是以.i作为文件扩展名。
- 编译阶段。编译器(cc1)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。
- 汇编阶段。接下来，汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成为一种叫做可重定位(relocatable)目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它的直接编码是机器语言指令而不是字符。如果我们在文本编辑器中打开hello.o文件，呈现的将是一对乱码。
- 链接阶段。请注意，我们的hello程序调用了`printf`函数，它是标准C库中的一个函数，每个C编译器都提供。`printf`函数存在于一个名为printf.o的单独的预编译目标文件中，而这个文件必须以某种方式并入到我们的hello.o程序中。链接器(ld)就负责处理这种并入，结果就得到hello文件，它是一个可执行目标文件。柯子岭文件加载到存储器后，由系统负责执行。

不同操作系统最终生成的可执行文件可能是不同的
- 第一个从贝尔实验室单身的Unix系统使用的是a.out格式
- System V Unix的早期版本使用的是COFF
- Windows使用的是COFF的一个变种，叫做PE
- 现代Unix系统，如Linux、各种BSD Unix以及SUN Solaris，使用的是Unix ELF。

其中不同格式基本概念都差不多，我们以linux系统中的ELF文件来分析。

#### 可重定位目标文件

下图是一个典型的ELF可重定位目标文件。ELF头(ELF header)以一个16字节的序列开始，这个序列描述了字的大小和生成该文件的系统字节顺序。ELF头剩下的部分包含帮助链接器接卸和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型(比如，可重定位、可执行或者是共享的)、机器类型(比如，IA32)、节头部表(section header table)的文件偏移，以及节头部表中的表目大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的表目(engry)。
![avatar](/img/in-post/Linux/201931201002.png)

夹在ELF头和节头部表之间的都是节。一个典型的ELF可重定位目标文件包含下面几个节：
- .text:已编译程序的机器代码
- .rodata:只读数据，比如printf语句中的格式串和开关语句的跳转表
- .data:已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中
- .bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占任何实际的磁盘空间
- .systab:一个符号表(sysbol table),它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。
- .rel.text:当链接器把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。
- .rel.data:被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。
- .debug:一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以-g选项调用编译驱动程序时，才会得到这张表。
- .line:原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时，才会得到这张表。
- .strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部的节名字。字符串表就是以null结尾的字符串序列。
