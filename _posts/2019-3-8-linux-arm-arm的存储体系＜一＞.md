---
layout: post
title: "arm-存储体系＜一＞"
subtitle: Arm存储体系介绍
author: "404"
header-style: text
tags:
  - Linux
  - arm
  - Memory
---

>本篇文章来源于《ARM体系结构与编程》，写得挺好

#### ARM存储系统概述

ARM存储系统的体系结构可以适应多种不同的嵌入式应用系统。 最简单的存储系统使用普通的地址映射机制，就像在一些简单的单片机系统中一样，地址空间的分配方式是固定的，系统中各部分都使用物理地址。而一些复杂的系统可能包括一种或者多种下面的技术，从而可以提供功能更为强大的存储系统：

- 系统中可能包含多种类型的存储器件， 如Flash、 ROM、SRAM和SDRAM等。 不同类型的存储器件 的速度和宽度（位数）等各不相同。 比如， LinkUp公司的L7205 芯片包含有2KB的片内ROM, 5KB的片内SRAM, 片外
均可以支持Flash/SRAM,也可以支持SDRAM。
- 通过使用Cache及WriteBuffer技术， 可以缩小处理器和存储系统的速度差别，从而提高系统的整体性能。
- 内存管理部件使用内存映射技术实现虚拟空间到物理空间的映射 。 这种映射机制对于嵌入式系统非常重要。通常，嵌入式系统的程序存在ROM/Flash中，这样，系统断电后， 程序能够得到保存。但是，ROM/Flash与SDRAM相比，速度通常要慢很多，而且嵌入系统中通常把异常中断向量表存放在RAM中。利用内存映射机制可以解决这种需求。在系统加电时将ROM/Flash映射为地址0, 这一样可以进行些初始化处理；当这些初始化处理完成后， 将SDRAM映射为地划 O, 并把系统程序加载到SDRAM中运行，这样，就能很好地解决嵌入式系统的需求问题了。
- 引入一些机制，保证将I/O操作映射成内存操作后，各种I/O操作能够得到正确的结果，在简单的存储系统中，这不存在问题。而当系统引入了Cache及Write Buffer后，就需要一些特别的措施。

本章中主要介绍以下内容。在介绍相关内容时，将以LinkUp公司的通用ARM芯片L7205作为例子。
- ARM中用于存储 管理的系统控制协处理器CP15。
- ARM中的存储管理部件MMU(MemoryManagement Unit)。
- ARM中的Cache及WriteBuffer技术。
- 快速进程上下文切换技术。

在ARM中还规定了一种比MMU结构更简单的且功能更弱的存储管理机制，称为保护部件PU(P rotectUnit)，这里对其不做详细介绍，用户如果需要，可以自己查看ARM相关的技术文档。

#### ARM中用于存储管理的系统控制协处理器CP15

在基于ARM的嵌入式应用系统中，存储系统通常是通过系统控制协处器CP15完成的。除了CPl5外，在具体的各种存储管理机制中，可能还会用到其他的些技术，如在MMU(存储管理部件）中，除了CP15外，还将使用页表等。

CP15可以包含16个32位的寄存器，其编号为0~15。实际上，对于某些编号的寄存器，可能对应有多个物理寄存器，在指令中可指定特定的标志位来区分这些物理寄存器。这种机制有些类似于ARM 中的寄存器，当处于不同的处理器模式时，某些ARM寄存器可能是不同的物理寄存器，比如对于寄存器SPSR, 每一种处理器模式下都对应一个独立的物理存储器（用户模式和系统模式对应同样的物理寄存器，这是一个例外）。

CP15中的寄存器可能是只读的，也可能是只写的，还有一些是可以读写的。对于每一种寄存器，将会详细介绍：
- 寄存器的访问类型（只读／只写／读写）。
- 各种访问操作对于寄存器的作用。
- 寄存器是否对应有多个物理寄存器。
- 寄存器的具体作用。
本节将主要介绍系统控制协处理器CP15 的寄存器， 包括访问CP15寄存器的指令和CP15中的寄存器。

##### 访问CP15寄存器的指令

访问CP15寄存器的指令有下面两种。
- MCR: ARM寄存器到协处理器寄存器的数据传送指令。
- MRC: 协处理器寄存器到ARM寄存器的数据传送指令。

MCR指令和MRC指令只能在处理器模式是系统模式时执行，在用户模式下执行MCR指令和MRC指令将会触发未定义指令的异常中断。

如果需要在用户模式下访问CP15中的寄存器，需要采用其他的方法。一种常用的做法是由操作系统定义一些SWI调用，这些SWI调用完成相应的功能，在用户模式下可以进行这些SWI调用。

**MCR**

MCR指令将ARM处理器的寄存器中的数据传送到协处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。
![avatar](/img/in-post/Linux/201931101001.png)

指令的语法格式
```
MCR{<cond>} pl5, 0, <Rd>, <CRn>, <CRrn>(, <opcode_2>}
MCR2 pl5, 0, <Rd>, <CRn>, <CRrn>(, <opcode_2>}
```
其中：
- <cond>为指令执行的条件码。当<cond>忽略时，指令为无条件执行。MCR2格式中，<cond>为0b1111，指令为无条件执行指令。
- <opcode_1>为协处理器将执行的操作码。对于CP15协处理器来说，<opcode_1>永远为0b000，当<opcode_1>不为0b000时，该指令操作结果不可预知。
- <Rd>为源寄存器的ARM寄存器，其值将被传送到的协处理器的寄存器中。<Rd>不能为PC,当其为PC时，指令操作结果不可预知。
- <CRn>作为目标寄存器的协处理器寄存器，其编号司能为C0,C1...C15。
- <CRm>附加的目标寄存器或者源操作数寄存器，用于区分同一个编号的不同物理寄存器。当指令中不需要提供附加信息时，将C0指定为<CRm>,否则指令操作结果不可预知。
- <opcode—2>提供附加信息，用于区别同一个编号的不同物理寄存器。当指令中没有指定附加信息时，省略<opcode_2>或者将其指定为0,否则指令操作结果不可预知。

指令操作伪代码：
```
if CondidionPassed(cond) then
send Rd value to Coprocessor[cp_num]
```

例子：下面的指令从ARM寄存器R4中将数据传送到协处理器 CP15的寄存器中Cl中。其中R4为ARM寄存器，存放源操作数；Cl、C0为协处理器寄存器，为目标寄存器；操作码l为0; 操作码2为0。
```
MCR p15, 0, R4, C1, C0, 0;
```

**MRC**

MRC指令将协处理器的寄存器中的数值传送到ARM处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。
![avatar](/img/in-post/Linux/201931101002.png)

指令的语法格式：
```
MRC/<cond>J plS, 0, <Rd>, <CRn>, <CRm>/, <opcode_2>}
MRC2 pl5, 0, <Rd>, <CRn>, <CRm>{, <opcode_2>}
```

- <CRn>为协处理器寄存器，存放第1个源操作数。
- 其他参数的用法参见MCR指令。

指令操作伪代码：
```
if ConditionPassed(cond) then
rd = value from Coprocessor[cp_num]
```
