---
layout: post
title: "Uboot Makefile分析"
subtitle: Uboot Makefile分析
author: "404"
header-style: text
tags:
  - Linux
  - GNU
  - Uboot
  - Make
---

# 1 MakeFile简介

　　Linux环境下的程序员如果不会使用GNU make来构建和管理自己的工程,应该
不能算是一个合格的专业程序员,至少不能称得上是Unix程序员。在Linux(unix)环
境下使用GN 的make工具能够比较容易的构建一个属于你自己的工程,整个工程的
编译只需要一个命令就可以完成编译、连接以至于最后的执行。不过这需要我们投入一
些时间去完成一个或者多个称之为Makefile文件的编写。此文件正是make正常工作
的基础。

　　所要完成的Makefile文件描述了整个工程的编译、连接等规则。其中包括:工程
中的哪些源文件需要编译以及如何编译、需要创建那些库文件以及如何创建这些库文
件、如何最后产生我们想要得可执行文件。尽管看起来可能是很复杂的事情,但是为工
程编写Makefile的好处是能够使用一行命令来完成“自动化编译”,一旦提供一个(通
常对于一个工程来说会是多个)正确的Makefile。编译整个工程你所要做的唯一的一件
事就是在shell提示符下输入make命令。整个工程完全自动编译,极大提高了效率。

　　make是一个命令工具,它解释Makefile中的指令(应该说是规则)。在Makefile
文件中描述了整个工程所有文件的编译顺序、编译规则。Makefile有自己的书写格式、
关键字、函数。像C语言有自己的格式、关键字和函数一样。而且在Makefile中可以
使用系统shell所提供的任何命令来完成想要的工作。Makefile(在其它的系统上可能
是另外的文件名)在绝大多数的IDE开发环境中都在使用,已经成为一种工程的编译
方法。

# 2. Uboot Ｍakefile

　　我们这里采用的Uboot源码版本是`u-boot-1.1.6`,更新版本的以后再分析。当我们需要进行系统移植的时候，肯定也是需要进行Uboot移植的，因为arm系统需要依靠uboot来引导。这里我们来看一下Uboot中的Makefile文件。

## 2.1 Uboot初始环境设置

```makefile
VERSION = 1
PATCHLEVEL = 1
SUBLEVEL = 6
EXTRAVERSION =
U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
VERSION_FILE = $(obj)include/version_autogenerated.h

HOSTARCH := $(shell uname -m | \
	sed -e s/i.86/i386/ \
	    -e s/sun4u/sparc64/ \
	    -e s/arm.*/arm/ \
	    -e s/sa110/arm/ \
	    -e s/powerpc/ppc/ \
	    -e s/macppc/ppc/)

HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
	    sed -e 's/\(cygwin\).*/cygwin/')

export	HOSTARCH HOSTOS

# Deal with colliding definitions from tcsh etc.
VENDOR=
```

　　这是Uboot主文件夹下的Makefile文件，当我们输入make指令的时候，就会执行这个Makefile中的内容，上面代码是最开头的一段，`VERSION`这些是介绍Uboot的版本，我们这里凑起来
就可以看到我们的版本是`1.1.6`。我们这里看到将变量设置了`U_BOOT_VERSION = 1.1.6`。

　　接下来是`HOSTARCH`、`HOSTOS`,是来查看我们编译环境的体系结构和操作系统。

## 2.2 编译目录设置

```makefile
ifdef O
ifeq ("$(origin O)", "command line")
BUILD_DIR := $(O)
endif
endif

ifneq ($(BUILD_DIR),)
saved-output := $(BUILD_DIR)

# Attempt to create a output directory.
$(shell [ -d ${BUILD_DIR} ] || mkdir -p ${BUILD_DIR})

# Verify if it was successful.
BUILD_DIR := $(shell cd $(BUILD_DIR) && /bin/pwd)
$(if $(BUILD_DIR),,$(error output directory "$(saved-output)" does not exist))
endif # ifneq ($(BUILD_DIR),)

OBJTREE		:= $(if $(BUILD_DIR),$(BUILD_DIR),$(CURDIR))
SRCTREE		:= $(CURDIR)
TOPDIR		:= $(SRCTREE)
LNDIR		:= $(OBJTREE)
export	TOPDIR SRCTREE OBJTREE

MKCONFIG	:= $(SRCTREE)/mkconfig
export MKCONFIG

ifneq ($(OBJTREE),$(SRCTREE))
REMOTE_BUILD 	:= 1
export REMOTE_BUILD
endif

# $(obj) and (src) are defined in config.mk but here in main Makefile
# we also need them before config.mk is included which is the case for
# some targets like unconfig, clean, clobber, distclean, etc.
ifneq ($(OBJTREE),$(SRCTREE))
obj := $(OBJTREE)/
src := $(SRCTREE)/
else
obj :=
src :=
endif
export obj src
```
　　这里如果我们外部命令设置了O参数，如`make O=/XX/XXX`，则会将`BUILD_DIR`设置成
这个目录，下面的那些就是判断这个目录是否存在，如果不存在的话就创建这个目录。最主要
的就是看如下4个：
- OBJTREE：输出目录
- SRCTREE：源码目录
- TOPDIR：顶层目录
- LNDIR：链接目录

　　然后这里有一个`export`命令，这里就相当于C语言里面的全局变量，如果这个makefile文件
将来还调用其他makefile文件，则在其他makefile文件里面也能访问这些变量。OBJTREE就是
将来我们输出`.o`等文件的目录，这里设置BUILD_DIR就是为了让生成文件不污染uboot源码，这里
我们就不具体分析了。

## 2.3 指定交叉编译工具链

```makefile

ifeq ($(OBJTREE)/include/config.mk,$(wildcard $(OBJTREE)/include/config.mk))

# load ARCH, BOARD, and CPU configuration
include $(OBJTREE)/include/config.mk
export	ARCH CPU BOARD VENDOR SOC

ifndef CROSS_COMPILE
ifeq ($(HOSTARCH),ppc)
CROSS_COMPILE =
else
ifeq ($(ARCH),ppc)
CROSS_COMPILE = powerpc-linux-
endif
ifeq ($(ARCH),arm)
CROSS_COMPILE = arm-linux-
endif
ifeq ($(ARCH),i386)
ifeq ($(HOSTARCH),i386)
CROSS_COMPILE =
else
CROSS_COMPILE = i386-linux-
endif
endif
ifeq ($(ARCH),mips)
CROSS_COMPILE = mips_4KC-
endif
ifeq ($(ARCH),nios)
CROSS_COMPILE = nios-elf-
endif
ifeq ($(ARCH),nios2)
CROSS_COMPILE = nios2-elf-
endif
ifeq ($(ARCH),m68k)
CROSS_COMPILE = m68k-elf-
endif
ifeq ($(ARCH),microblaze)
CROSS_COMPILE = mb-
endif
ifeq ($(ARCH),blackfin)
CROSS_COMPILE = bfin-elf-
endif
ifeq ($(ARCH),avr32)
CROSS_COMPILE = avr32-
endif
endif
endif

export	CROSS_COMPILE

# load other configuration
include $(TOPDIR)/config.mk
```

　　这里我们来制定相关的编译工具，因为面临不同的系统架构，我们用的编译工具是不同的，
比如我们要编译适合`i386`体系的，我们直接采用`gcc`、`ld`等命令就行，但如果我们需要编译
`arm`体系的话，就需要使用`arm-linux-gcc`、`arm-linux-ld`等命令。那么我们`ARCH`这些
变量从哪里来呢？我们在使用make指令的时候，会调用`$(TOPDIR)/mkconfig`里面来
设置。

```makefile
echo "ARCH   = $2" >  config.mk
echo "CPU    = $3" >> config.mk
echo "BOARD  = $4" >> config.mk

[ "$5" ] && [ "$5" != "NULL" ] && echo "VENDOR = $5" >> config.mk

[ "$6" ] && [ "$6" != "NULL" ] && echo "SOC    = $6" >> config.mk
```
　　在这里我们会将根据make后带的参数来配置`config.mk`里面的内容，那么`config.mk`在
哪？我们在`$(TOPDIR)/mkconfig`里面会`cd ./include`,所以这个文件在顶级目录的include文件夹
下。

整体的Uboot Makefile流程如下：
![avatar](/img/in-post/Linux/201932201001.png)
