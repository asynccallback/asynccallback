---
layout: post
title: "Uboot-Nandflash进阶＜二＞"
subtitle: Uboot-Nandflash进阶分析
author: "404"
header-style: text
tags:
  - Linux
  - Arm
  - Uboot
  - NANDflash
---
>本篇文章转载自[【详解】如何编写Linux下Nand Flash驱动](https://www.crifan.com/files/doc/docbook/linux_nand_driver/release/html/linux_nand_driver.html),写的挺好

# 2. 硬件特性

## 2.9 Nand Flash引脚(Pin)的说明
![avatar](/img/in-post/Linux/201933101006.png)
　　上图是常见的Nand Flash所拥有的引脚（Pin）所对应的功能，简单翻译如下：
![avatar](/img/in-post/Linux/201933101007.png)
　　在数据手册中，你常会看到，对于一个引脚定义，有些字母上面带一横杠的，那是说明此引脚/信号是低电平有效，比如你上面看到的RE头上有个横线，就是说明，此RE是低电平有效，此外，为了书写方便，在字母后面加“＃”，也是表示低电平有效，比如我上面写的CE＃；如果字母头上啥都没有，就是默认的高电平有效，比如上面的CLE，就是高电平有效。

### 2.9.1 为何需要ALE和CLE
　　硬件上，有了电源的Vcc和接地的Vss等引脚，很好理解，但是为何还要有ALE和CLE这样的引脚，为何设计这么多的命令,把整个系统搞这么复杂，关于这点，最后终于想明白了：   
　　设计命令锁存使能(Command Latch Enable, CLE) 和 地址锁存使能(Address Latch Enable，ALE)，那是因为，Nand Flash就8个I/O，而且是复用的，也就是，可以传数据，也可以传地址，也可以传命令，为了区分你当前传入的到底是啥，所以，先要用发一个CLE（或ALE）命令，告诉Nand Flash的控制器一声，我下面要传的是命令（或地址），这样，里面才能根据传入的内容，进行对应的动作。否则,Nand Flash内部,怎么知道你传入的是数据,还是地址,还是命令,也就无法实现正确的操作了。

### 2.9.2 Nand Flash只有8个I/O引脚的好处
　　在Nand Flash的硬件设计中，你会发现很多个引脚。关于硬件上为何设计这样的引脚，而不是直接像其他存储设备，比如普通的RAM，直接是一对数据线引出来，多么方便和好理解啊。
　　关于这样设计的好处：   
1. 减少外围连线
相对于并口(Parellel)的Nor Flash的48或52个引脚来说，的确是大大减小了引脚数目，这样封装后的芯片体积，就小很多。现在芯片在向体积更小，功能更强，功耗更低发展，减小芯片体积，就是很大的优势。同时，减少芯片接口，也意味着使用此芯片的相关的外围电路会更简化，避免了繁琐的硬件连线。
2. 提高系统的可扩展性   
因为没有像其他设备一样用物理大小对应的完全数目的addr引脚，在芯片内部换了芯片的大小等的改动，对于用全部的地址addr的引脚，那么就会引起这些引脚数目的增加，比如容量扩大一倍，地址空间/寻址空间扩大一倍，所以，地址线数目/addr引脚数目，就要多加一个，而对于统一用8个I/O的引脚的Nand Flash，由于对外提供的都是统一的8个引脚，内部的芯片大小的变化或者其他的变化，对于外部使用者(比如编写Nand Flash驱动的人)来说，不需要关心，只是保证新的芯片，还是遵循同样的接口，同样的时序，同样的命令，就可以了。这样就提高了系统的扩展性。

说白了，对于旧的Nand Flash所实现的驱动，这些软件工作，在换新的硬件的Nand Flash的情况下，仍然可以工作，或者是通过极少的修改，就同样可以工作，使得软硬件兼容性大大提高。

1.2.10. Nand Flash的一些典型(typical)的特性
页擦除时间是200us，有些慢的有800us
块擦除时间是1.5ms
页数据读取到数据寄存器的时间一般是20us
串行访问（Serial access）读取一个数据的时间是25ns，而一些旧的Nand Flash是30ns，甚至是50ns
输入输出端口是地址和数据以及命令一起multiplex复用的
Nand Flash的编程/擦除的寿命：即，最多允许的擦除的次数
以前老的Nand Flash，编程/擦除时间比较短，比如K9G8G08U0M，才5K次，而后来的多数也只有10K=1万次，而现在很多新的Nand Flash，技术提高了，比如，Micron的MT29F1GxxABB，Numonyx的 NAND04G-B2D/NAND08G-BxC，都可以达到100K，也就是10万次的编程/擦除，达到和接近于之前常见的Nor Flash，几乎是同样的使用寿命了。

封装形式
48引脚的TSOP1封装 或 52引脚的ULGA封装

1.2.11. Nand Flash控制器与Nand Flash芯片
关于Nand Flash的控制器Controller和Nand Flash芯片chip之间的关系，觉得有必要解释一下：

首先，我们要知道的是，我们写驱动，是写Nand Flash 控制器的驱动，而不是Nand Flash 芯片的驱动，因为独立的Nand Flash芯片，一般来说，是很少直接拿来用的，多数都是硬件上有对应的硬件的Nand Flash的控制器，去操作和控制Nand Flash，包括提供时钟信号，提供硬件ECC校验等等功能，我们所写的驱动软件，是去操作Nand Flash的控制器

然后由控制器去操作Nand Flash芯片，实现我们所要的功能。

1.2.12. Nand Flash中的特殊硬件结构
由于Nand Flash相对其他常见设备来说，比较特殊，所以，特殊的设备，就有特殊的设计，就对应某些特殊的硬件特性，就有必要解释解释：

页寄存器（Page Register）：

由于Nand Flash读取和编程操作来说，一般最小单位是页，所以Nand Flash在硬件设计时候，就考虑到这一特性，对于每一片（Plane），都有一个对应的区域专门用于存放，将要写入到物理存储单元中去的或者刚从存储单元中读取出来的，一页的数据，这个数据缓存区，本质上就是一个缓存buffer，但是只是此处datasheet里面把其叫做页寄存器page register而已，实际将其理解为页缓存，更贴切原意。

而正是因为有些人不了解此内部结构，才容易产生之前遇到的某人的误解，以为内存里面的数据，通过Nand Flash的FIFO，写入到Nand Flash里面去，就以为立刻实现了实际数据写入到物理存储单元中了，而实际上只是写到了这个页缓存中，只有当你再发送了对应的编程第二阶段的确认命令，即0x10，之后，实际的编程动作才开始，才开始把页缓存中的数据，一点点写到物理存储单元中去。

所以，简单总结一下就是，对于数据的流向，实际是经过了如下步骤：
