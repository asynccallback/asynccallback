---
layout: post
title: "HTTP报文——首部"
subtitle: HTTP报文——首部
author: "404"
header-style: text
tags:
  - HTTP
---


# 1. HTTP报文

　　HTTP报文是由三部分组成：
- 起始行：对报文进行描述
- 首部：一些描述属性
- 主体：可选的、包含数据部分

　　HTTP报文可以分为：请求报文、响应报文。其中请求报文会向web服务器请求一个动作；响应报文会将请求的结果返回客户端。

　　其中请求报文的格式：
```
<method> <request-URL> <version>
<headers>

<entrty-body>
```

　　响应报文的格式：
```
<method> <status> <reason-phrase>
<headers>

<entrty-body>
```

　　现在解释下各个部分的含义：
- 起始行  
  - method：客户端希望服务器对资源执行的动作。是一个单独的词，比如 GET、HEAD或POST
  - request-RUL：命名了所请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要 URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是 URL的主机/端口
  - version：报文所使用的 HTTP 版本，其格式看起来是这样的：
    - HTTP/\<major\>.\<minor\>
  - status-code：这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（ “ 成功”、“ 出错” 等）
  - reason-phrase：数字状态码的可读版本， 包含行终止序列之前的所有文本。原因短语只对人类有意义，因此，比如说，尽管响应行 HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK 中原因短语的含义不同， 但同样都会被当作成功指示处理
- 首部
  - header：可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（ :），然后是一个可选的空格，接着是一个值，最后是一个 CRLF。首部是由一个空行（ CRLF） 结束的， 表示了首部列表的结束和实体主体部分的开始。有些 HTTP 版本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。
- 实体
  - entity-body：实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个CRLF结束

　　下图简单来说明上述：
![avatar](/img/in-post/Linux/201941901001.png)

# 2. 首部

　　首部和方法配合工作，共同决定了客户端和服务器能做什么事情。在请求和响应报文中都可以用首部来提供信息，有些首部是某种报文专用的，有些
首部则更通用一些。可以将首部分为五个主要的类型。

## 2.1 通用首部

　　有些首部提供了与报文相关的最基本的信息，它们被称为通用首部。它们像和事佬儿一样，不论报文是何类型，都为其提供一些有用信息。

　　例如，不管是构建请求报文还是响应报文，创建报文的日期和时间都是同一个意思，因此提供这类信息的首部对这两种类型的报文来说也是通用的。表3-11列出了通用的信息性首部。
![avatar](/img/in-post/Linux/201941901002.png)

　　HTTP/1.0引入了第一个允许HTTP应用程序缓存对象本地副本的首部，这样就不需要总是直接从源端服务器获取了。最新的HTTP版本有非常丰富的缓存参数集。
![avatar](/img/in-post/Linux/201941901003.png)

## 2.2 请求首部

　　请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。
![avatar](/img/in-post/Linux/201941901004.png)

### 2.2.1 Accept首部

　　Accept首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，它们不想要什么。这样，服务器就可以根据这些额外信息，对要发送的内容做出更明智的决定。Accept首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费其时间和带宽来发送客户端无法使用的东西。
　　![avatar](/img/in-post/Linux/201941901005.png)

### 2.2.2 条件请求首部

　　有时客户端希望为请求加上某些限制。比如，如果客户端已经有了一份文档副本，就希望只在服务器上的文档与客户端拥有的副本有所区别时，才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应之前，确保某个条件为真。
![avatar](/img/in-post/Linux/201941901006.png)

### 2.2.3 安全请求首部

　　HTTP本身就支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。
![avatar](/img/in-post/Linux/201941901007.png)

### 2.2.3 代理请求首部
![avatar](/img/in-post/Linux/201941901008.png)

## 2.3 响应首部

　　响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些首部有助于客户端处理响应，并在将来发起更好的请求。
![avatar](/img/in-post/Linux/201941901009.png)

### 2.3.1 协商首部

　　如果资源有多种表示方法——比如，如果服务器上有某文档的法语和德语译稿，HTTP/1.1可以为服务器和客户端提供对资源进行协商的能力。这里列出了几个首部，服务器可以用它们来传递与可协商资源有关的信息。
![avatar](/img/in-post/Linux/201941901010.png)

### 2.3.2 安全响应首部

　　我们已经看到过安全请求首部了，本质上这里说的就是HTTP的质询/响应认证机制的响应侧。
![avatar](/img/in-post/Linux/201941901011.png)

## 2.4 实体首部

　　有很多首部可以用来描述HTTP报文的负荷。由于请求和响应报文中都可能包含实体部分，所以在这两种类型的报文中都可能出现这些首部。

　　实体首部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体首部可以告知报文的接收者它在对什么进行处理。
![avatar](/img/in-post/Linux/201941901012.png)

### 2.4.1 内容首部

　　内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。比如，Web浏览器可以通过查看返回的内容类型，得知如何显示对象。
![avatar](/img/in-post/Linux/201941901013.png)

### 2.4.2 实体缓存首部

　　通用的缓存首部说明了如何或什么时候进行缓存。实体的缓存首部提供了与被缓存实体有关的信息——比如，验证已缓存的资源副本是否仍然有效所需的信息，以及更好地估计已缓存资源何时失效所需的线索。
![avatar](/img/in-post/Linux/201941901014.png)
